<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YuXiang Bao&#39;s Blog</title>
  
  <subtitle>分享计算机学习知识，来看看吧🥳</subtitle>
  <link href="https://ethanbao27.github.io/atom.xml" rel="self"/>
  
  <link href="https://ethanbao27.github.io/"/>
  <updated>2024-12-14T16:13:47.184Z</updated>
  <id>https://ethanbao27.github.io/</id>
  
  <author>
    <name>Yuxiang Bao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TaiwindCSS基本使用</title>
    <link href="https://ethanbao27.github.io/2024/12/14/Taiwind%20css%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://ethanbao27.github.io/2024/12/14/Taiwind%20css%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2024-12-14T15:55:24.000Z</published>
    <updated>2024-12-14T16:13:47.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="taiwindcss">Taiwindcss</h1><ul><li>用于react 的application ui组件库</li></ul><h3 id="installation">Installation</h3><h4 id="不使用react">不使用React</h4><p>创建tailwind.config.js file和download</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -D tailwindcss</span><br><span class="line">npx tailwindcss init</span><br></pre></td></tr></table></figure><p>在配置文件中添加模板文件路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** @<span class="built_in">type</span> &#123;import(<span class="string">&#x27;tailwindcss&#x27;</span>).Config&#125; */</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  content: [<span class="string">&quot;./src/**/*.&#123;html,js&#125;&quot;</span>],</span><br><span class="line">  theme: &#123;</span><br><span class="line">    extend: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主css文件添加@taiwind 指令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@tailwind</span> base;</span><br><span class="line"><span class="keyword">@tailwind</span> components;</span><br><span class="line"><span class="keyword">@tailwind</span> utilities;</span><br></pre></td></tr></table></figure><p>完成，可以在html中使用taiwind添加class类名了</p><h4 id="如果使用vite驱动框架">如果使用Vite驱动框架：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install tailwindcss@next @tailwindcss/vite@next</span><br></pre></td></tr></table></figure><p>在vite.config.ts：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> tailwindcss <span class="keyword">from</span> <span class="string">&#x27;@tailwindcss/vite&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">tailwindcss</span>()</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>导入主css文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;tailwindcss&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="使用react">使用React</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;tailwindcss&#x27;).Config</span>&#125; */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">content</span>: [</span><br><span class="line">    <span class="string">&quot;./src/**/*.&#123;js,jsx,ts,tsx&#125;&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">theme</span>: &#123;</span><br><span class="line">    <span class="attr">extend</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在css中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@tailwind</span> base;</span><br><span class="line"><span class="keyword">@tailwind</span> components;</span><br><span class="line"><span class="keyword">@tailwind</span> utilities;</span><br></pre></td></tr></table></figure><h3 id="bg-color">bg color</h3><p>不同灰度级的背景色调色盘</p><p><strong>css类</strong>:bg-black/white/slate(偏蓝灰)-(100-950),gray,zinc(纯灰),neutral, stone,red,orange,amber,lime....</p><p>设置<strong>不透明度</strong>：e.g.bg-sky-500<strong>/100,75,50</strong></p><p>其他状态：hover:b-cyan-600</p><h3 id="w">w</h3><p>w-4 代表<strong>1rem</strong></p><p>w-1 0.25rem</p><p>w-px 使用像素</p><p>w-1/2 分数设置百分比</p><p>w-full 全宽</p><p>w-screen 视口宽度</p><p>min-w- 最小宽度</p><p><strong>媒体查询</strong>md:min-w-0 在中等屏幕尺寸下应用</p><h3 id="h">h</h3><p>与w同理</p><p>h-dvh 动态视口高度</p><p>h-lvh 最大视口高度</p><p>h-svh 最小</p><h3 id="size">size</h3><p>与w，h同理，同时设置wh</p><h3 id="text">text</h3><p>xs，sm，base，lg，xl，2xl，4xl</p><p><strong>font-bold</strong></p><h3 id="rounded">rounded</h3><p>=border 同text</p><h4 id="flex">flex</h4><p>flex设置为弹性布局</p><p>flex-row flex-col设置主轴</p><p>flex-wrap 换行</p><p>justify-center 沿主轴居中</p><p>justify-between/around/evenly</p><p>items-center...</p><p>gap 设置子元素艰巨</p><h3 id="m">m</h3><p>设置margin</p><p>mx-4 my-4 水平和垂直方向</p><p>mt mr mb ml 上下左右方向</p><p>-m-4 负值</p><h3 id="p">p</h3><p>设置padding</p><p>同m</p><h3 id="transform">transform</h3><p>Transform 设置变换效果</p><p><strong>translate 平移</strong> -x-4 -y-2</p><p>rotate-45 顺时针</p><p>scale-110 缩放1.1倍</p><p>skew-x-12 倾斜度数</p><h3 id="transition">transition</h3><p>transition 过渡</p><p>transition-colors 渐变颜色</p><p><strong>transition-transform 变换相关属性进行过渡</strong></p><p>duration-300 持续时间300ms</p><p>ease-in/out/in-out 缓动函数</p><p>delay-200 延迟ms</p><h3 id="animation">animation</h3><p>animation-ping 逐渐淡出</p><p>-bounce 弹跳动画</p><p>-spin 旋转动画</p><p>-pulse 呼吸动画</p><h3 id="响应式">响应式</h3><p>sm: md: lg:</p><h3 id="状态类">状态类</h3><p>hover: active: focus:</p>]]></content>
    
    
    <summary type="html">介绍前端css快捷开发框架，tailwindcss的基本类名。</summary>
    
    
    
    <category term="前端" scheme="https://ethanbao27.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://ethanbao27.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="css" scheme="https://ethanbao27.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络考试复习（详细版）</title>
    <link href="https://ethanbao27.github.io/2024/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    <id>https://ethanbao27.github.io/2024/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/</id>
    <published>2024-11-03T13:13:40.000Z</published>
    <updated>2024-11-04T07:30:10.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络总复习">计算机网络总复习</h1><h2 id="第一章-概述">第一章 概述</h2><p>计算机网络：结点node（计算器、交换机、路由器）+链路link</p><p>功能：数据通信、资源共享</p><p>Internet TCP/IP ISP 局域网与广域网</p><blockquote><p><strong>电路交换</strong>：突发式传输、适用低频</p><p><code>传输时间少、有序到达、但要建立连接、不灵活、利用率低、无差错控制</code></p><p><strong>报文交换</strong>：无需连接、存储转发、利用率较高、差错控制、重传代价高</p><p><code>无需连接、有序到达、但转发时延高</code></p><p><strong>分组交换</strong>：无需连接、存储转发、分组定长（拆分为多个分组）、重传代价低</p><p><code>更加灵活，前面两种的折中、利用率非常高、传输时间少、支持差错控制、但需要携带很多额外控制信息、且不是有序到达</code></p></blockquote><h4 id="网络分类">网络分类</h4><p>WAN、MAN（城域网）、LAN、PAN（个域网）</p><p>广播、点对点</p><p>总线型（争用问题）、环形、星型（点对点）、网状（灵活但控制复杂线路成本高）</p><p>公用网、专用网</p><p>有线网、无线网</p><h4 id="性能指标">性能指标</h4><p>bps、kbps、Mbps、Gbps、Tbps （按照<spanclass="math display">\[10^3\]</span>递增）</p><p><strong>速率</strong>（数据率、比特率、数据传输率）bps</p><p><strong>带宽</strong>：某信道允许通过的最高数据率 bps<strong>或者</strong>表示 信号频带范围 Hz</p><p><strong>吞吐量</strong>：某个网络或节点、信道单位时间内的实际通过的数据量（<strong>实际的综合数据率</strong>）B</p><p><strong>时延</strong>：数据一端传送到另一端所需的时间</p><p><strong>发送时延/传输时延=<spanclass="math inline">\(\frac{数据长度(bit)}{发送速率(bit/s)}\)</span></strong>：将数据推向信道所花费的时间（准备过程）</p><p><strong>传播时延=<spanclass="math inline">\(\frac{信道长度(m)}{电磁波在信道中的传播速度(m/s)}\)</span></strong>：电磁波在信道中传播一定的距离所花费的时间（传播过程）</p><p><strong>处理时延</strong>：受网络负载、路由器性能等诸多因素影响（一般不考虑）</p><p><strong>排队时延</strong>：数据排队进入、发出路由器所花的时间</p><p><strong>总时延=发送时延+传播时延+处理时延+排队时延</strong></p><p><strong>时延带宽积</strong>（bit）：单向传播时延x带宽</p><p><strong>往返时延RTT</strong>：从发送方发送完数据，到发送方收到来自接收方的确认数据总共经历的时间</p><p><strong>信道利用率</strong>：某个信道有百分之多少的时间是有数据通过的。</p><blockquote><p>利用率低会浪费带宽、利用率太高会导致网络拥塞</p></blockquote><h4 id="分层结构">分层结构</h4><p>每一个层次负责实现一个或多个功能，上一层实体通过“接口”，请求相邻下一层的“<strong>接口</strong>”，SAP（服务访问点）</p><p><strong>实体</strong>、对等实体、协议（水平）：通信规则集合、<strong>服务</strong>（垂直）：下层提供给上层的功能调用；</p><p>OSI：7层法律标准；TCP/IP模型：事实</p><p>五层模型（教学用）</p><p>PDU：协议数据单元、SDU：服务数据单元、PCI：协议控制信息</p><p><strong>协议三要素</strong>：语法（格式）、语义、同步（时许）</p><table><colgroup><col style="width: 10%" /><col style="width: 32%" /><col style="width: 57%" /></colgroup><thead><tr><th>OSI参考模型</th><th>任务</th><th>功能</th></tr></thead><tbody><tr><td>应用层</td><td>实现特定网络应用</td><td>略</td></tr><tr><td>表示层</td><td>解决不同主机上信息不一致的问题</td><td>数据格式转换</td></tr><tr><td>会话层</td><td>管理进程间会话</td><td>会话管理</td></tr><tr><td>传输层</td><td>实现端到端通信</td><td>复用、分用、差错控制、流量控制、连接管理、可靠数据传输</td></tr><tr><td>网络层</td><td>将分组从源结点转发到目的结点</td><td>路由选择、分组转发、拥塞控制、网际互联、差错控制、流量控制、连接管理、可靠数据传输</td></tr><tr><td>数据链路层</td><td>确保相邻节点之间的链路逻辑上无差错</td><td>差错控制、流量控制</td></tr><tr><td>物理层</td><td>实现相邻节点比特之间的传输</td><td>需定义电路接口参数、信号的含义/电气特性等</td></tr></tbody></table><p>区别TCP/IP模型，对上可以提供无连接不可靠的IP和UDP服务，而OSI只能提供有连接、可靠的服务</p><h2 id="第二章-物理层">第二章 物理层</h2><p>任务：实现<u>相邻节点</u>之间比特（0或1）的传输</p><h3 id="通信原理">通信原理</h3><p>信源、信宿、信号、信道</p><p>信源通过信道传输信号给信宿</p><p>信号是数据的载体，数据是信息的实体</p><p>信号有数字信号（离散，如电压正负）、模拟信号（连续，波形）</p><p>每一个信号称作一个<strong>码元</strong></p><p>一个码元可以携带的比特数据位：一个周期内可能出现K种信号</p><p>则<br /><span class="math display">\[1码元=\log_2Kbit\]</span></p><p>波特Baud（率）：每秒传输几个码元(码元/秒)</p><p>比特率：每秒传输几个比特（bit/s）</p><p>通信原理中的带宽：某信道允许通过的信号频带范围Hz（最大频率-最小频率）</p><p>噪声：对信道产生干扰，影响信号的数据传输效率。</p><p>电磁波、电压会受到环境电场、磁场的干扰</p><h5 id="奈氏准则">奈氏准则</h5><p><u><strong>没有噪声（理想低通信道）</strong></u>的信道来说，它的极限波特率是2W波特，其中W是信道的频率带宽Hz。<span class="math display">\[极限比特率=2W\log_2Kb/s\]</span> K为一个信号周期内可能出现的信号种类</p><h5 id="香农定律">香农定律</h5><p><strong><u>有噪声、带宽有限的信道</u></strong>，则 <spanclass="math display">\[极限比特率=W\log_2(1+\frac{S}{N})(bit/s)\]</span> W:信道的频率带宽（Hz）</p><p><span class="math inline">\(\frac{S}{N}：信噪比\)</span> <spanclass="math display">\[信噪比=\frac{S}{N}=\frac{信号的功率（w）}{噪声的功率（w）}\]</span> 用单位记录：db（分贝）分贝转比值，假设分贝为mdb： <spanclass="math display">\[m分贝=10\log_{10} \frac{S}{N}\]</span></p><h5 id="编码解码调制解调">编码&amp;解码、调制&amp;解调</h5><p>编码：二进制数据转换为数字信号</p><p>解码：数字信号转换为二进制数据</p><p>调制：二进制数据转换为模拟信号</p><p>解调：模拟信号转换为二进制数据</p><p><strong>有线网络适配器：编码-解码器</strong></p><p><strong>光猫：调制-解调器</strong></p><h5 id="编码技术">编码技术</h5><p>不归零编码（NRZ）：低0高1，中不变</p><p>归零编码（RZ）：低0高1，中归0</p><p>反向非归零编码（NRZI）：跳0不跳1看起点，中不变</p><p><strong>曼彻斯特编码</strong>：跳0反跳1看中间，中必变</p><p><strong>差分曼彻斯特编码</strong>；跳0不跳1看起点，中必变</p><h5 id="调制方法">调制方法</h5><p>基带信号：来自信源的数字信号（需要调制后才能在某些信道上传输，例如空气）</p><ol type="1"><li>调幅AM</li></ol><p>有信号就调成正弦波，信号为0就无幅度</p><ol start="2" type="1"><li>调频FM</li></ol><p>调制正弦波频率</p><ol start="3" type="1"><li>调相PM</li></ol><p>调制正弦波相位</p><p>QAM（正交幅度调制）：AM+FM,即<spanclass="math inline">\(1码元=\log_2mnbit\)</span></p><p>QAM-16:16种码元</p><h5 id="传输介质">传输介质</h5><p>导向型（有限）：双绞线、同轴电缆、光纤</p><p>非导向型：无限传输介质</p><p>单模光纤适合远距离传输（只传输一条光线）、多摸光纤适合近距离传输</p><p>以太网对有限传输介质的命名规则</p><p>速度（Mbps）+Base+介质信息</p><p>介质信息：数字则为同轴电缆，5代表最远传输距离500m，F代表光纤，T代表双绞线</p><p>电磁波：无线电波、微波（保密性差）</p><p>波长越短、频率越高、带宽越高</p><p>短波通信需要指向性强、长波不需要</p><h5 id="物理层接口特性">物理层接口特性</h5><p>机械特性：接线器形状尺寸、引脚数目、排列、固定和锁定装置</p><p>电气特性：接口电缆各条线上出现电压范围、传输速率、距离限制</p><p>功能特性：某条线上出现某一电平的电压的含义</p><p>过程特性（规程特性）；对于不同功能的各种可能事件的出现顺序</p><h5 id="物理层设备">物理层设备</h5><p>传输距离越远，越有可能信号失真</p><p>因此根据以太网规范限制传输距离长度</p><p>可以通过<strong>中继器（半双工通信</strong>）延续信号，将电压整形为标准的电压</p><p><strong>集线器Hub</strong>：多端口中继器。将一个端口收到的信号整形再生后，转发到其他所有端口</p><p>不可同时发送数据，会导致<strong>冲突</strong></p><p>Hub的N个端口对应N个网段，各网段属于同一个“<strong>冲突域</strong>”</p><p>合并Hub，组成更大的冲突域（碰撞域💥）</p><p>集线器组成的网络拓扑结构是总线型的（逻辑上），物理上是星形</p><ul><li>连接的带宽共享</li></ul><h2 id="第三章-数据链路层">第三章 数据链路层</h2><p>功能：封装成帧、透明传输、差错控制（（位错（检错编码、纠错编码）、帧错）、流量控制、可靠传输（通过滑动窗口））</p><p>两种链路（信道）：点对点（广域网）、广播（局域网）</p><p>结点：主机、路由器</p><p>链路：两个结点之间物理通道</p><p>数据链路：两个结点之间逻辑通道（链路+协议）</p><p>帧：链路层协议数据单元</p><blockquote><p>加强物理层传输原始比特流的功能，将物理连接改造成逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</p></blockquote><p>提供<strong>无确认无连接服务、有确认无连接服务、有确认面向连接服务</strong></p><h5 id="封装成帧">封装成帧</h5><p>为IP数据报添加首部和尾部：帧定界</p><p>帧同步：接收方应该能区分帧的起始和终止</p><p>数据部分&lt;=MTU</p><p>透明传输：对高层不可见。</p><p>数据链路层的透明性在于能够无视传输的数据内容，但由于帧定界符会与内容混淆，所以需要实现某些规则</p><h6 id="实现透明传输">实现透明传输</h6><p><strong>字符填充法</strong>（传输的帧）：SOH，EOT的8bit数据</p><p>在内容部分的控制信息前加入ESC转译义字符，在接收端去除所有转义字符</p><p><strong>零比特填充法</strong>：一连串比特连续发送，只要连续5个1，就立刻填入一个0，接收端发现5个1就把后面的0删除</p><h5 id="差错控制">差错控制</h5><p>有差错就要检错，实现了检错的编码</p><p>差错的发生是由于噪声引起的：线路的电气特性导致全局性的随机噪声（热噪声）-&gt;提高信噪比、外界短暂的特点原因的局部的冲击噪声（<strong>产生差错的主要原因</strong>）-&gt;<u>利用编码技术解决</u></p><p>差错</p><ul><li>位错 0变1，1变0</li><li>帧错 丢失、重复、失序</li></ul><blockquote><p>不是所有链路都要差错检测！对于提供无确认无连接服务（通信质量好的链路）不需要</p></blockquote><p>有确认：就是有<strong>重传</strong>机制，有差错检测</p><p>检错编码：奇偶校验码、循环冗余码CRC</p><p>纠错编码：海明码</p><blockquote><p>物理层与数据链路层编码不一样：一个是对于单个比特的传输同步、一个是一组比特的传输过程有无差错</p></blockquote><h6 id="奇偶校验码">奇偶校验码</h6><p>n-1位信息元+1位校验元</p><p>奇校验码：“1”个数为奇数</p><p>偶校验码：“1”个数为偶数</p><h6 id="crc循环冗余码">CRC循环冗余码</h6><p>代传数据除以生成多项式（2进制编码），余数为FCS帧检验序列/冗余码，帧加上冗余码发送</p><p>接收方接受数据除以生成多项式，余数为0则接受，余数不为0则1丢弃</p><p>无差错接受：</p><p><code>“凡是接收端数据链路层接受的帧，都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”</code></p><p>并不是无比特差错的传输，因此<strong>不是可靠传输</strong></p><h6 id="海明码">海明码</h6><p>海明距离：码距，差错的个数</p><p>码距为n，可以检测n-1比特错</p><ol type="1"><li>确认冗余码/校验码位数r,假设源信息有m位</li></ol><p><span class="math display">\[海明不等式：2^r&gt;=m+r+1\]</span></p><ol start="2" type="1"><li>确认校验码和数据的位置，校验码放在序号为<spanclass="math inline">\(2^n\)</span>的位置（n从1开始，在低位）（eg.1,2,4...）</li></ol><p>1号校验码xx1（最低位1，负责1，3，5，7校验）</p><p>2号校验码x1x（第二位1，负责2，3，6，7校验）</p><p>4号校验码1xx（第三位1，负责4，5，6，7）</p><ol start="3" type="1"><li><p>采用偶校验，确保每个校验码负责的对应位“1”个数为偶数，从而计算出海明码</p></li><li><p>检错并纠错，收到的数据对每个校验码对应的负责位数校验检查“1”个数，查看哪一位出错（每一位异或，再结合起来）</p></li></ol><h5 id="可靠传输与流量控制">可靠传输与流量控制</h5><p>流量控制：原因较高的发送速度与较低接受能力的不匹配</p><p>（二层流量控制是点对点的，四层流量控制是端到端）</p><p><strong>手段</strong>：接收端发送给发送端一个<strong>窗口公告</strong>，控制发送速率，使接收方有足够的缓冲空间来接受每一个帧</p><ol type="1"><li>停止等待协议</li></ol><p>发送帧-确认帧-发送帧-确认帧 低效</p><p><code>发送窗口大小=1，接受窗口大小=1</code></p><ol start="2" type="1"><li>滑动窗口协议</li></ol><p>发送窗口（发送的数据）、接受窗口确认发送帧、发送窗口前进</p><p>后退N帧协议（GBN）</p><p><code>发送窗口大小&gt;1,接受窗口大小=1</code></p><p>选择重传协议（SR）</p><p><code>发送窗口大小&gt;1,接受窗口大小&gt;1</code></p><p>可靠传输：发送什么、收到什么</p><p><strong>滑动传输解决的就是可靠传输与流量控制</strong>（收不下就不给确认+发送方自动重传ARQ）</p><h6 id="停止-等待协议">停止-等待协议</h6><p>除了镇内比特差错，还会出现<strong>丢包</strong>问题（帧、包、段）</p><p>不考虑全双工，仅考虑半双工</p><p>发送一个帧接受一个帧，计时器到期重传,⏰&gt;平均RTT，帧必须编号，重传则丢弃确认帧</p><blockquote><p>RTT(往返时延包括发送时延)吗？一般不包括，包括传播时延+排队时延+处理时延（接收方处理返回确认消息时间）</p><p>上文是单向RTT,双向RTT是双向传播时延</p></blockquote><p><span class="math display">\[信道利用率=\frac{L}{CT}\]</span></p><p>T:发送周期，从开始发送数据，到收到第一个确认帧为止（计算T：发送时延+双向RTT）</p><p>L：T内发送L比特数据</p><p>C：发送方数据传输率 <span class="math display">\[信道吞吐率=信道利用率*发送方的发送速率\]</span> 停止等待的信道利用率低，大部分时间发送方空闲</p><h6 id="后退n帧协议gbn">后退N帧协议（GBN）</h6><p>解决停止-等待协议的信道利用率低问题，连续发送多个帧（<strong>流水线技术</strong>）</p><ol type="1"><li>必须增加序号范围（防止出错）</li><li>发送方需要缓存多个分组</li></ol><p>滑动窗口：01234567...发送的数据必须在窗口内</p><p>接受窗口只有1格，收到n号帧就返回对n帧的确认帧（也可以累计确认，发送对前n帧的确认帧）</p><p>已经发完的帧（不在窗口）、正在发送的帧，还能发送的帧（在窗口）、不能发送的帧（不在窗口）</p><p><strong>窗口已满则不能发送</strong>，但可以放在缓存</p><p>GBN累积确认：对前n号帧的全部接受</p><p>超时计时器：后退N帧，若N帧的发送帧/确认帧没有收到，重传N帧以及后续未确认的帧，ACK一直发送ACKN-1</p><p>GBN总结：累积确认、接收方按序接受、ACK最大按序到达的帧，提高信道利用率，但是重传的效率偏低</p><h6 id="选择重传协议sr">选择重传协议（SR）</h6><p>解决GBN累积确认导致的批量重传带来的效率降低问题</p><p>解决方法：设置单个确认、加大接受窗口、设置接受缓存、缓存乱序到达的帧</p><p>发送，接受窗口：N</p><p>发送窗口：发送完被确认的帧、已经发送但等待确认的、还能发送的</p><p>接受窗口：希望收到但没收到的、收到且返回确认的（<strong>在缓存中</strong>）、等待接受的</p><p>发送方：上层调用后SR发送帧或加入发送缓存、收到ACK移动窗口、超时时间后只重传一个帧</p><p>接收方：对于接受窗口内的帧<strong>来者不拒</strong>，失序的帧将被缓存并返回给发送方该帧的确认帧（<strong>收到谁确认谁</strong>），直到所有帧均被收到为止，这时可以将一批帧按需交付给上层，然后向前移动窗口</p><p>如果接收到窗口左边的帧，返回ACK；</p><p>超时重传；</p><p>帧的标识位是有限的，会出现n号帧是新帧还是旧帧的无法确认，因此窗口不能过大<span class="math display">\[W_Tmax=W_Rmax=2^{(n-1)}\]</span> n:帧编码个数</p><p>W:窗口大小</p><p>SR总结：数据帧逐一确认、只重传出错帧、接收方有缓存</p><h5 id="信道划分介质访问控制">信道划分&amp;介质访问控制</h5><p>点对点链路（PPP，广域网）、广播式链路（总线以太网、局域网：星型（逻辑总线型））</p><p>介质访问控制：采取一定措施，使得两对节点之间的通信不会发生相互干扰：</p><ol type="1"><li>静态划分信道</li></ol><p>频分多路复用FDM、时分多路复用TDM、波分开多路复用WDM、码分多路复用CDM</p><ol start="2" type="1"><li>动态分配信道</li></ol><p>轮询访问：令牌传递协议</p><p>随机访问介质：ALOHA，CSMA，CSMA/CD，CSMA/CA</p><p>多路复用技术：多个信号组合在一条物理通道</p><p>实质：广播信道组合为点对点信道</p><ol type="1"><li>FDM</li></ol><p>每个用户同时分带宽的各个频段</p><ol start="2" type="1"><li>TDM</li></ol><p>带宽一致，每个用户交替使用信道（轮流、周期性）</p><ol start="3" type="1"><li>STDM（统计时分复用）</li></ol><p>发送到集中器的缓存，按需动态分配</p><ol start="4" type="1"><li>WDM</li></ol><p>本质：光波的频分复用</p><ol start="5" type="1"><li>CDM</li></ol><p>每个比特指定固定的m位芯片序列</p><p>发送1时候发送对应芯片序列、发送0时候发送芯片序列<strong>反码</strong></p><ol type="1"><li>发送的时候两个芯片序列互相正交，规格化内积为0</li></ol><p><span class="math display">\[S·T=\frac{1}{m}\sum_{i=1}^{m}S_iT_i=0\]</span></p><ol start="2" type="1"><li>两个向量到了公共信道上，线性相加，S-T</li><li>数据分离：合并的数据和原站点规格化内积，得到发送的数据，1代表1，-1代表0</li></ol><p><span class="math display">\[S·(S-T)=1\]</span></p><p><span class="math display">\[T·(S-T)=-1\]</span></p><p>以下为动态划分信道</p><p>特点：信道并非在用户通信时固定分配给用户</p><p>随机访问：所有用户可随机发送信息，发送信息时占据<strong>全部带宽。（不协调）</strong></p><h6 id="aloha">ALOHA</h6><p>每个站点不监听信道，随机重发 成功率低</p><h6 id="时隙aloha">时隙ALOHA</h6><p>时间片同步接入信道。发生冲突则等待到下一个时间片再重发</p><h6 id="csma载波监听多路访问协议">CSMA（载波监听多路访问协议）</h6><p><code>先听再说！</code></p><p>CS：发送数据前检测总线电压摆动值（检测碰撞）</p><p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上</p><p>坚持CSMA：监听信道忙，则监听直到有空闲直接传输</p><p>如果有冲突等待一个时间再监听</p><p>非坚持CSMA：忙则不继续监听，等待一个随机时间再监听</p><p>p-坚持CSMA：对于信道空闲的时候，以p概率进行直接传输；1-p概率等到下一个时间槽再传输</p><p>忙则持续监听直到信道空闲，再以p概率发送</p><p>若冲突则等待下一个时间槽再监听并重复以上过程</p><h6 id="csmacd">CSMA/CD</h6><p><code>先听再说，边听边说</code></p><p>CS：载波监听</p><p>MA：多点接入 总线型</p><p>CD：碰撞检测</p><p>监测到数据错误（碰撞💥），立刻停发数据</p><p>单程端到端传播时延：<span class="math inline">\(\tau\)</span></p><p>B监测到碰撞时间（A发送的数据到达）：<spanclass="math inline">\(t=\tau\)</span></p><p>假设B发送的时间为<spanclass="math inline">\(t=\tau-\delta\)</span></p><p>则A检测到碰撞时间<spanclass="math inline">\(t=2\tau-\delta\)</span></p><p>因此，最迟需要<spanclass="math inline">\(t=2\tau\)</span>时间才能监测到自己发送的数据有没有和其他数据产生碰撞（两倍总线端到端时延，一个争用期）</p><p>重传时间：截断二进制指数规避算法</p><ol type="1"><li>退避时间=基本争用期<span class="math inline">\(2\tau\)</span></li><li>定义k为重传次数（小于10），再大就一直保持10</li><li>从<spanclass="math inline">\([0,1,2^k-1]\)</span>中随机取出一个数r</li></ol><p><span class="math display">\[重传退避时间=r倍的基本退避时间=2r\tau\]</span></p><ol start="4" type="1"><li>重传16次还未成功，则抛弃此帧并向网络层报告（网络拥挤）</li></ol><p>帧太短会再发送完毕之前检测不到碰撞，因此需要规定最小帧长：帧的传输时延至少要两倍于信号在总线上的传播时延<span class="math display">\[\frac{帧长(bit)}{数据传输速率}\geq2\tau\]</span> 因此 <span class="math display">\[最小帧长=总线传播时延\times数据传输速率\times2=2\tau\times数据传输速率\]</span> <strong>以太网规定最小帧长64Bytes</strong></p><h6 id="csmaca">CSMA/CA</h6><p>应用：无线局域网</p><p>空闲发送RTS（request to send），收到接收端的CTS（clear tosend）,开始预约信道</p><p>接收端收到帧后用CRC检验，正确响应ACK帧，收到则继续发送，否则进行二进制指数退避算法重传</p><h5 id="局域网基本概念和体系结构">局域网基本概念和体系结构</h5><p>多采用分布式控制和广播式通信</p><p>星形拓扑、总线型拓扑✅（以太网：逻辑总线）、环形拓扑、树形拓扑</p><p>IEEE 802标准</p><p>IEEE 802.3 以太网介质访问控制协议（CSMA/CD）及物理层技术规范</p><p>IEEE 802.5 令牌环网（单点故障）</p><p>IEEE 802.8 光纤技术环网</p><p>IEEE 802.11 无线局域网(WLAN)</p><p>LLC子层、MAC子层</p><h5 id="以太网">以太网</h5><p>Ethernet 使用CSMA</p><p>满足速率要求：10Mb/s~10Gb/s</p><p>DIX Ethernet v2或IEEE 802.3</p><p><strong>无连接、不可靠的服务</strong></p><p>10BASE-T 无屏蔽双绞线 10Mb/s 100m 曼彻斯特编码</p><p>局域网通信：适配器（网卡）</p><p>MAC地址 48bit 前24bit代表厂家（IEEE规定）后24位厂家自定</p><p>物理层：前导码+MAC帧</p><p>MAC层：6B目的地址（全F为广播）、6B源地址、类型（上层协议）、数据（IP数据报）46（最小帧长64B-6-6-2-4）-1500B（MTU）、FCS（帧检验序列）</p><h6 id="高速以太网">高速以太网</h6><p>100BASE-T 双绞线 100Mb/s 星形 可以全双工无冲突</p><p>吉比特以太网 光纤或双绞线 1Gb/s 可以全双工无冲突</p><p>10吉比特 光纤 10Gb/s 只支持全双工 无冲突</p><h6 id="ieee-802.11-无线局域网">IEEE 802.11 无线局域网</h6><table><colgroup><col style="width: 10%" /><col style="width: 17%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 17%" /><col style="width: 13%" /><col style="width: 13%" /></colgroup><thead><tr><th>2B</th><th>2B</th><th>6B</th><th>6B</th><th>6B</th><th>2B</th><th>6B</th></tr></thead><tbody><tr><td>帧控制</td><td>生存周期ID</td><td>RA接收端</td><td>TA发送端</td><td>DA目的地址</td><td>序列控制</td><td>SA源地址</td></tr></tbody></table><p>AP无线接入点：基站</p><p>发送端和接收端：两个基站的MAC地址</p><p>BSS：基本服务集，由一个AP（Access Point接入点）和多个无线客户端</p><p>ESS：扩展服务集，多个BSS互联</p><p>基站之间有限通信</p><p>漫游：自动选择最近的AP</p><h6 id="vlan">VLAN</h6><ul><li>流量隔离（广播帧的<strong>泛洪</strong>）</li><li>用户管理</li><li>降低路由成本</li></ul><p>将局域网内的设备划分成与物理位置无关的逻辑组，每个VLAN是单独的广播域</p><p>交换机转发表 MAC地址：端口 映射</p><ul><li>VLAN表 VLAN id：端口 or MAC地址</li></ul><p>贴标签：在类型前加入4B VLAN标记（后12位VID，0-4095）</p><h6 id="wan">WAN</h6><p>广域网：分组交换技术，强调资源共享</p><p>PPP：全双工链路，无流量控制和纠错，帧定界符，透明传输，多种网络层协议、多种类型链路、差错检测、检测连接状态、最大传输单元、网络层地址协商、数据压缩协商</p><p>LCP（链路控制）身份验证、NCP（网络控制）</p><p>定界符7E，转义字符7D，地址字段A FF</p><p>F、A、C、协议、信息部分、FCS、F</p><h5 id="扩展以太网">扩展以太网</h5><p>集线器：具有冲突域</p><p>网桥：转发与过滤MAC帧，能够区分网段</p><p>交换机：多端口网桥</p><p>网桥转发表自学习：地址和端口，没有就写入广播，有就转发，每隔一段时间清空</p><p>交换机自学习算法，与网桥一样</p><p>冲突域：每个结点都能收到所有被发送的帧</p><p>广播域：网络中能接收到一个结点发出广播帧的所有设备的集合</p><p>（物理层）中继器、集线器：不能隔离冲突域和广播域</p><p>（链路层）网桥、交换机：能隔离冲突域、不能隔离广播域</p><p>（网络层）路由器：都能</p><h2 id="第四章-网络层">第四章 网络层</h2><p>sdn：控制平面</p><p>IP数据报：版本、首部长度5-<strong>4B</strong>、区分服务、总长度<strong>1B</strong>、标识、标志、片偏移、TTL、协议（数据部分）、首部检验和、源地址和目标地址：32位、可选字段0～40B、填充：全0，把首部补成4B整数倍</p><h4 id="ip数据报分片">IP数据报分片</h4><p>从0开始</p><p>不能超过以太网的MTU 1500Bytes，超过则ip分片</p><p>标识：标志同一数据报的分片</p><p>标志：最低两位有意义，DF（不许分片）1禁止，0允许，MF（更多分片），1还有分片，0代表没有分片</p><p>片偏移<strong>8B</strong>：某片在原分组中的相对位置（<strong>字节序除以8Bytes</strong>）</p><h4 id="ipv4">IPv4</h4><ol type="1"><li><p>在哪个网络？</p></li><li><p>在网络下的哪个主机？</p></li></ol><p>IP编址：</p><ol type="1"><li>分类IP地址：<网络号><主机号>32位/4B 每1B点分十进制</li></ol><p>A类 1～126 网络号1B 主机号3B 0</p><p>最大网络数 <span class="math inline">\(2^7-2\)</span> 1 126最大主机数 <span class="math inline">\(2^{24}-2\)</span></p><p>B类 128～191 网络号2B 主机号2B 10 最大网络数 <spanclass="math inline">\(2^14-1\)</span> 128 191 最大主机数 <spanclass="math inline">\(2^{16}-2\)</span></p><p>C类 192～223 网络号3B 主机号1B 110 最大网络数 <spanclass="math inline">\(2^8-2\)</span> 192 223 最大主机数 <spanclass="math inline">\(2^8-2\)</span></p><p>D类 224～239 多播地址 1110</p><p>E类 240～255 保留 1111</p><p>0.0.0.0只可以作为源地址，本网络范围内表示主机，路由表表示默认路由</p><p>网络号全0，主机号特定值 只能源地址，表示本网范围内某个主机</p><p>255.255.255.255（全1）只能作为目的地址，广播地址，路由器不转发</p><p>网络号特定值，主机号全0 不可作为地址，表示一个网络</p><p>网络号127，主机号任何数（不全为0或者1），可以作为目的地址和源地址环回地址 本地软件环回测试 （软件测试）</p><h5 id="私有内部ip地址">私有（内部）IP地址</h5><p>A类</p><p>10.0.0.0~10.255.255.255 网段个数1</p><p>B类</p><p>172.16.0.0～172.31.255.255 网段个数16</p><p>C类</p><p>192.168.0.0～192.168.255.255 网段个数256</p><h4 id="网络地址转换-nat">网络地址转换 NAT</h4><p>目的：私有ip转换为公有ip</p><p>NAT路由器：NAT转换表 WAN端对应LAN端的ip和端口号</p><h4 id="子网划分和子网掩码">子网划分和子网掩码</h4><p><strong>将主机号划分为：子网号、主机号</strong></p><p>主机号不能全0（网络号）和全1（广播）</p><p>子网掩码与IP地址逐位相与，得到子网网络地址</p><p>直接交付（子网掩码相与查看网络号是否匹配）、间接交付（特定主机路由、路由表路径检测、默认路由、丢弃报告出错）</p><h5 id="cidr无分类编址">CIDR无分类编址</h5><p>IP地址后加上/，写上网络前缀的位数</p><p>CIDR子网掩码：网络前缀多少就前多少个1</p><h6 id="超网">超网</h6><p>多个子网聚合成一个较大的子网，叫做构成超网</p><p>取网络号前n位的交集，合并成一个更大的网络</p><h6 id="最长前缀匹配">最长前缀匹配</h6><p>使用CIDR，查找路由表可能得到多个匹配结果，应选择具有最长网络前缀的路由</p><h5 id="arp协议">ARP协议</h5><p>知道源ip地址的MAC地址（封装的时候填入），如何知道目的ip地址的MAC地址？</p><p>查询本地ARP高速缓存（ip：MAC），没有则使用ARP协议</p><p>主机发送ARP广播帧，目的MAC地址全F（1）</p><p>有对应MAC地址的主机响应单播ARP响应地址</p><p>“下一跳”：到下一个具有ip地址（MAC地址）的设备</p><p>10-20min更新一次ARP缓存</p><p>主机要找本网内：ARP找到本网主机MAC；找外网：ARP找到本网路由器MAC</p><p>路由器要找本网内：ARP找到本网主机MAC；找外网：ARP找到另一个路由器MAC</p><h5 id="dhcp">DHCP</h5><p>静态配置：ip+子网掩码+默认网关</p><p>动态ip地址分配：DHCP服务器（应用层，基于udp），地址重用</p><p>租用期：限时</p><p>主机广播DHCP发现报文（找服务器）、服务器广播DHCP提供报文（预分配ip）、主机发送DHCP请求报文（请求分配）、服务器广播DHCP确认报文（正式分配ip）</p><h6 id="icmp">ICMP</h6><p>支持主机或路由器的差错（异常）报告</p><p>网络探询</p><p>五种差错报告报文：终点不可达、拥塞丢弃、超时、首部出错、重定向（改变路由：不是最好的路由）</p><p>ICMP前8Bytes+IP首部+数据字段前8Bytes=ICMP差错报告报文</p><p>装入IP字段（加IP首部）</p><p>组播、特殊地址、第二个及以后分片不发送ICMP差错报告</p><p>ICMP询问报文</p><ul><li>回送请求和回答报文收到询问主机必须给源主机或路由器发送ICMP回送回答报文<strong>ping</strong></li><li>时间戳请求和回答报文 回答当前时间日期，进行时钟同步和时间测量</li></ul><p>应用：PING、Traceroute（跟踪源点到达终点的路径）</p><h4 id="ipv6">IPV6</h4><blockquote><p>IPv4已经耗尽，CIDR NAT治标不治本...</p></blockquote><p>基本首部、有效载荷</p><p>基本首部：版本、优先级、流标签（从一个源到一个目的）、有效载荷长度、下一个首部、跳数限制、源地址（128bit）、目的地址（128bit）</p><ul><li>删除校验和字段</li><li>删除可选字段，加入扩展首部</li><li>即插即用（自动配置），不需DHCP</li><li>首部长度是8B整数倍,IPv4是4B整数倍</li><li>IPv6只能在主机出处分片，IPv4可以在路由器和主机分片</li><li>ICMPv6：附加报文分组过大</li><li>支持资源预分配</li><li>取消协议字段，改成下一个首部字段</li><li>取消总长度字段，该用有效载荷长度字段</li><li>取消服务类型字段</li></ul><p>表示：冒号十六进制记法</p><p>单薄、多播、任播</p><p>兼容性：双栈协议、隧道技术</p><p>回顾：路由选择协议</p><ul><li>内部网关协议 RIP、OSPF</li><li>外部网关协议 BGP</li></ul><h4 id="rip">RIP</h4><p><strong>分布式、基于距离向量的路由选择</strong> 简单</p><p>每个路由器都维护从它自己到<strong>其他每一个目的网络</strong>的<strong>唯一最佳距离记录</strong>（最短跳数）</p><table><thead><tr><th>目的网络</th><th>距离</th><th>下一跳路由器</th></tr></thead><tbody><tr><td>Net2</td><td>1</td><td>直接交付</td></tr><tr><td>Net1</td><td>2</td><td>R1</td></tr><tr><td>Net4</td><td>2</td><td>R3</td></tr></tbody></table><p>距离=跳数=从源到目的经过路由器个数</p><p>RIP仅允许一条路由包含15个路由器，距离为16代表网络不可达</p><ol type="1"><li>只能和相邻的路由器交换信息</li><li>路由器交换的信息是<strong>自己的路由表</strong></li><li>30秒交换一次路由表</li></ol><p>路由器初始只知道距离为1的下一跳，接着和相邻路由器交换并更新路由信息</p><p>经过若干次更新，达到<strong>收敛</strong></p><ol type="1"><li>修改相邻路由器x发来RIP报文所有表项，下一跳改为x，距离+1</li><li>对修改后RIP报文每一项：</li></ol><ul><li><p>路由表没有Net，则把该项目填入表</p></li><li><p>有Net，则查看下一跳：</p></li><li><p>下一跳是x，则用收到的项目更新路由表</p></li><li><p>不是x，则原来距离比x远则更新，否则不处理</p></li></ul><ol start="3" type="1"><li>180s内没收到x的更新路由表，则把x标记为不可达，即距离设置为16</li><li>返回</li></ol><p><strong>RIP报文在UDP数据报中</strong>，也就是说RIP是<strong>应用层</strong>协议</p><p>一个RIP最多20个路由信息</p><p>缺点：会造成<strong>传输错误信息的循环</strong>，好消息快收敛，坏消息慢收敛</p><h4 id="ospf">OSPF</h4><p>开放最短路径优先 Dijkstra 最短路径算法SPF</p><p>分布式链路状态协议</p><ol type="1"><li>使用泛洪法向自治系统内所有路由器发送信息，而每一个相邻路由器又将此信息发送给所有相邻路由器<strong>广播</strong></li><li>发送信息是<strong>相邻路由器的路由状态</strong></li><li>只有<strong>当链路状态发生变化</strong>时，路由器才向所有路由器泛洪</li></ol><p>链路状态路由算法</p><p>使用Dijkstra算法算出最优选择</p><p>OSPF将自治系统划分为<strong>区域</strong>，适合<strong>大规模系统</strong></p><p>在IP数据报内发送，是网络层协议</p><p>30min更新一次，收敛速度很快，坏消息也很快</p><h4 id="bgp">BGP</h4><p>AS自治系统间交换信息，通过BGP发言人（边界路由器）</p><p>发生变化才更新</p><p><strong>BGP交换的信息是到达某个网络所要经过的一系列AS</strong></p><p>交换路径向量，沿某一路径<spanclass="math inline">\((AS_1,AS_2)\)</span>可以到达网络<spanclass="math inline">\(N5,N6,N7\)</span></p><p>BGP报文放入TCP报文的数据段，是<strong>应用层协议</strong></p><p>BGP支持CIDR，开始运行交换整个路由表，后续之交换变化的信息</p><p>BGP-4连接</p><ol type="1"><li>OPEN报文</li><li>UPDATE报文</li><li>KEEPALIVE报文：周期性确认连通性</li><li>NOTIFACTION报文：可以关闭连接</li></ol><p>总结：RIP内部网关，使用广播UDP，跳数最少，距离-向量；</p><p>OSPF是内部网关，使用IP，代价最低，泛洪，链路状态；</p><p>BGP是外部网关，使用TCP，较好，路径-向量；</p><h4 id="ip组播">IP组播</h4><p>单播：点对点，源-目的</p><p>广播：点对多点，全部端口</p><p>组播（多播）：只给相同需求的主机发送，点对多点，<strong>最后一步路由器才会复制</strong></p><p>IP组播地址：<strong>部分</strong>D类地址：224.0.0.0~239.255.255.255，一个D类地址表示一个<strong>组播组</strong>。只能用作<strong>分组的目标地址</strong>，最大努力交付UDP，不产生ICMP</p><p>组播MAC地址01-00-5E开头，后面将IP地址后23位映射到以太网地址</p><h5 id="igmp">IGMP</h5><p>让局域网上的组播路由器知道网内是否有主机参加或退出了某个<strong>组播组</strong></p><p>使用IP数据包</p><ol type="1"><li>发送IGMP报文给某个路由器，声明想要加入某个组播组</li><li>利用协议把关系发给其他组播路由器</li><li>周期性探询本地路由器是否是组播组的成员，经过几次探寻未响应就不再把成员关系发给其他的组播路由器</li></ol><h5 id="组播路由选择协议">组播路由选择协议</h5><p>组播转发树</p><h5 id="移动ip">移动IP</h5><p>到达不同物理地点，保持ip地址不变</p><h4 id="网络层设备">网络层设备</h4><p>路由器：多输入/输出端口的专用计算器，任务是转发分组</p><p>根据路由选择协议构造路由表、更新维护路由表、根据转发表对分组进行转发</p><p>输入端口：接受分组、直到网络层分组排队：查表和转发（<strong>产生时延</strong>）</p><p>输出端口： 设置<strong>缓冲队列</strong>，排队输出</p><p>分组丢失原因：<strong>输入队列或输出队列缓冲区因为排队溢出</strong></p><p>根据路由表（默认路由全0）来得出转发表</p><h2 id="第五章-传输层">第五章 传输层</h2><h4 id="概述">概述</h4><p>端系统层次：主机独有</p><p>为应用层提供通信服务</p><ol type="1"><li>提供进程与进程间的逻辑通信</li><li>复用和分用</li><li>报文进行差错检测</li></ol><p>TCP、UDP</p><p>面向连接、可靠和无连接、不可靠</p><p><strong>复用</strong>：应用层所有的应用进程都可以通过传输层再传输到网络层</p><p><strong>分用</strong>：传输层从网络层收到数据后交付给对应应用进程</p><p>端口：传输层SAP（服务访问点），本地意义</p><p>端口号</p><ul><li>服务端：熟知端口号0～1023，登记端口号1024～49151</li><li>客户端：49152～65536动态选择</li></ul><p>FTP：21</p><p>TELNET：23</p><p>SMTP：25</p><p>DNS：53</p><p>TFTP：69</p><p>HTTP：80</p><p>SNMP：161</p><p>套接字Socket=（ip，port）</p><h4 id="udp">UDP</h4><p>复用分用、差错检测</p><p>无连接、最大努力交付</p><p>面向报文，<strong>长度不改变</strong>，适合一次性少量数据</p><p>首部8B，数据字段可以为0</p><p>首部：源端口号2B，目的端口号2B，UDP长度2B，UDP检验和2B</p><p>找不到目的端口号丢弃报文，发送ICMP“端口不可达”差错报告报文</p><h5 id="udp校验">UDP校验</h5><p>伪首部：模仿ip首部，<strong>只有计算校验和时出现</strong></p><h4 id="tcp">TCP</h4><p>虚连接，点对点连接（进程对进程）</p><p>可靠有序，不丢不重</p><p>全双工通信：发送缓存（准备发送的数据&amp;已发送但未收到的数据）；接受缓存（按序到达但尚未被应用程序读取的数据&amp;不按序到达的数据）</p><p><strong>面向字节流</strong>：传输层将应用层报文视作连续字节流</p><h5 id="首部格式">首部格式</h5><p>20B首部，源端口目的端口各2B，总共4B，</p><p>序号：<strong>字节流的第一个字节的顺序编号</strong></p><p>确认号：期望收到对方下一个报文段的第一个数据字节的序号，若确认号位N，则证明到N-1点所有数据已正确收到</p><p>数据偏移（首部长度）：TCP报文段的数据起始处距离TCP报文段段起始处有多远，4B一个单位</p><p>紧急位URG：为1时在缓存区优先发送</p><p>确认位ACK：为1时确认位有效</p><p>推送位PSH：为1时接收方尽快交付接受应用进程</p><p>复位RST：为1时需要释放TCP连接</p><p><strong>同步位SYN</strong>：表明是连接请求/连接接受报文</p><p><strong>终止位FIN</strong>：为1时表明发送方数据已发完，要求释放连接</p><p>窗口：自己的接收窗口，可以容纳的字节流，对方应根据窗口设置发送窗口（<strong>流量控制</strong>）</p><p>检验和：检验首部+数据，检验时加上伪首部12B，第四个字段为6</p><p>紧急指针：URG=1时有意义，指出紧急数据的字节数</p><p>选项：可选，最大报文段长度MSS、窗口扩大、时间戳、选择确认...</p><h5 id="tcp连接管理">TCP连接管理</h5><p>客户-服务器方式（C/S）</p><p><strong>三次握手</strong>-四次挥手**</p><p>C：连接请求报文段，无数据</p><ul><li>SYN=1，seq=x（随机）序号</li></ul><p>S：为TCP连接分配缓存和变量，返回<strong>确认报文段</strong>，无数据</p><ul><li>SYN=1，ACK=1，ack=x+1（想要收到的下一个序号），seq=y（随机）</li></ul><p>C：确认的确认，可以携带报文数据，分配TCP连接缓存和变量</p><ul><li>SYN=0（同步已经完成了），ACK=1，seq=x+1，ack=y+1（想要收到下一个序号）</li></ul><p>SYNFLOOD泛洪攻击</p><ul><li>攻击者发送大量第一个握手数据包SYN，服务器返回ACK确认后，攻击者不进行确认。TCP连接处于挂起状态，浪费服务器资源导致崩溃</li></ul><p>连接释放</p><p>C：发送连接释放报文段，停止发送数据</p><ul><li>FIN=1，seq=u</li></ul><p>S：服务器送回确认报文段--半关闭状态</p><ul><li>ACK=1，seq=v，ack=u+1</li></ul><p>S：服务器发送完毕所有数据，发出连接释放报文段</p><ul><li>FIN=1，ACK=1，seq=w，ack=u+1</li></ul><p>C：客户端送回一个确认报文段，在等待时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭</p><ul><li>ACK=1，seq=u+1，ack=w+1</li></ul><h5 id="可靠传输">可靠传输</h5><p>可靠：保证接收方进程从缓冲区读出的字节流与接收方一致</p><h6 id="确认机制">确认机制</h6><p>直到接收方完整接收到报文段，才把缓存区中的发送报文段删除（确认报文段）</p><p><strong>累积确认</strong>：只确认第一个丢失字节开始的报文段</p><p><strong>重传</strong>：超时重传</p><p>RTTs（加权平均往返时间）：自适应算法计算的时间</p><p>冗余ACK（确认）：快速重传，每当比期望序号大的失序报文段到达时、发送一个冗余ACK，指明下一个期待字节的序号</p><p><strong>可靠传输在数据链路层已经讲过</strong></p><h5 id="流量控制">流量控制</h5><p>发送方的速率放慢</p><p>TCP利用滑动窗口机制实现流量控制</p><p>接收方根据<strong>接受缓存</strong>大小，动态调整发送方发送窗口大小、即接受窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的<strong>发送窗口取接受窗口rwnd和拥塞窗口cwnd的最小值</strong></p><p>e.g.ACK=1，ack=201(期望收到下一个是201开头的报文段)，rwnd=300（允许发送201-500B的窗口）</p><p>然后发送窗口往前移动，发两次100B的报文段（最大报文段），然后发送窗口满了，进入等待状态，直到接收方传来新的确认以及rwnd的大小，改变窗口大小并前进，重复以上过程</p><p>如果窗口为0，启动一个持续计时器，到期后发送<strong>0窗口探测报文段</strong>，接收方给出现在的窗口值，若为0则继续等待开启计时器</p><h5 id="拥塞控制">拥塞控制</h5><p>条件：对资源需求的<spanclass="math inline">\(总和\ge可用资源\)</span></p><p>网络吞吐量随输入负荷增大而下降，因此要协调防止过多的数据注入到网络中</p><blockquote><p>与流量控制区别：流量控制是点对点一对一对，拥塞控制是多对一的，有很多主机占据一条带宽</p></blockquote><h6 id="四种算法">四种算法</h6><p>慢开始、拥塞避免、快重传、快恢复</p><p>假设：</p><ol type="1"><li>数据单方向传送，另一个方向只传送确认</li><li>接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度</li></ol><p><span class="math display">\[发送窗口=Min(接受窗口rwnd,拥塞窗口cwnd)\]</span></p><p><strong>接受窗口</strong>：接收方根据接受缓存设置的值，并告诉发送方，反映接收方容量</p><p><strong>拥塞窗口</strong>：发送方根据自己估算的网络拥塞程度设置的窗口值，反映网络当前容量</p><ol type="1"><li><strong>慢开始</strong>和拥塞避免</li></ol><p>开始cwnd=1，“指数增长”，直到ssthresh门限初始值16，然后开始拥塞避免，”加法增大“，直到网络拥塞，记录下当前的cwnd拥塞窗口，设置新的ssthresh=<spanclass="math inline">\(\frac{cwnd}{2}\)</span>,设置cwnd=1，重复慢开始流程。</p><ol start="2" type="1"><li>快重传和快恢复</li></ol><p>慢开始、拥塞避免“加法增大”、收到3个重复的ACK（说明冗余了），立刻执行快重传算法（比超时计时器快，节省时间），快恢复“乘法减小”，降到新的门限制为<spanclass="math inline">\(\frac{cwnd}{2}\)</span>，然后继续加法增大...</p><h2 id="第六章-应用层">第六章 应用层</h2><p>为应用程序的通信提供服务</p><p>定义：</p><ul><li>应用进程交换的报文类型，请求还是响应？</li><li>各种报文类型的语法，如报文中的各个字段机器详细描述</li><li>字段的语义、即包含在字段中的信息的含义</li><li>进程何时、如何发送报文，以及对报文进行的响应的规则</li></ul><p>文件传输、访问和管理、电子邮件、虚拟终端、查询服务和远程作业登陆</p><p>FTP、SMTP、POP3、HTTP、DNS</p><p>C/S模型、P2P模型</p><h4 id="dns">DNS</h4><p>域名解析为ip地址</p><p>根域名 .</p><p>顶级域名</p><ul><li>国家 cn,us,uk</li><li>通用顶级域名 com,net,org,gov,int,aero,museum,travel</li><li>基础结构域名/反向域名 arpa（ip反DNS到域名）</li></ul><p>二级域名</p><ul><li>类别域名 ac,com,edu,gov,mil,net,org</li><li>行政区域名 bj,js</li><li>自定义域名</li></ul><p>三级域名</p><p>四级域名</p><p><strong>域名树🌲</strong>表示</p><p><strong>DNS服务器：层次划分</strong></p><p>特殊：<strong>本地域名服务器</strong>，优先发给本地DNS Server</p><p>如果本地DNS服务器没有，查询<strong>根域名服务器</strong> 13个但有更多分服务器</p><p>两种方式：递归查询和迭代查询</p><p><strong>递归查询</strong>：根域名服务器知道下一级顶级域名服务器的位置，然后是权限域名服务器（<strong>只能负责一个区：每一个区是某个域名及其子域名的管理，自定义</strong>），如果还不能完成请求，那就再给出其他的权限域名服务器地址进行查询，直到查询成功逐层返回，直到给本地域名服务器</p><p><strong>迭代查询</strong>：由本地域名服务器一个个询问（多用）</p><h4 id="ftp">FTP</h4><p>文件上传、下载</p><p>C/S协议，TCP实现可靠传输</p><p>1个主进程，多个从属进程</p><p>20端口</p><p>文本模式：ASCII</p><p>二进制模式：Binary</p><h4 id="电子邮件">电子邮件</h4><p>SMTP客户、邮件服务器</p><p>邮件服务器间POP3，IMAP</p><p>端口25</p><p>C/S</p><h4 id="www和http">WWW和HTTP</h4><p>World Wide Web，大规模联机的信息储藏空间</p><p>使用统一资源定位符URL标识唯一资源HTML（超文本标记语言HyperTextMarkdown Language）</p><p>URL格式：<协议名>://<主机>:<端口>/<路径></p><p>通过超链接获取资源，这些资源通过超文本传输协议HTTP（HyperTextTransfer Protocol）</p><p>C（Browser浏览器）/S（Server）</p><p>一个服务器监听TCP端口80</p><p>浏览器分析URL，向DNS请求解析为IP地址，浏览器与服务器建立TCP连接，发送HTTP请求报文，获得HTTP响应报文，获取资源，浏览器解析并展示，释放TCP连接</p><p>HTTP 无状态、无连接（虽然有TCP连接） Cookie本地存储历史记录</p><p>连接方式：</p><ul><li>非持久连接 TCP连接三次握手接下来发送和接受HTTP报文，关闭TCP连接</li><li>持久连接多次请求报文的时候不关闭TCP连接，分为流水线式（等待两个RTT）和流水线式（一个RTT）</li></ul><h5 id="http报文结构">HTTP报文结构</h5><p>面向文本，每一个字段都是<strong>ASCII码</strong></p><p><strong>请求报文</strong>：方法 URL 版本 回车行CRLF</p><p>首部字段名 值 CRLF</p><p>...CRLF</p><p>主体</p><p><strong>响应报文</strong>：版本（HTTP/1.1 HTTP/2 HTTP/3） 状态码 短语CRLF （状态行）</p><p>首部字段名 值 CRLF</p><p>...CRLF</p><p>主体</p><p><strong>响应状态码</strong>：</p><ul><li>1xx表示通知信息，请求收到或正在处理</li><li>2xx表示成功，接受</li><li>3xx表示重定向，如需完成请求需要进一步行动</li><li>4xx表示客户出错，如请求中语法错误或不能完成</li><li>5xx表示服务器出错，如服务器失效或无法完成请求</li></ul>]]></content>
    
    
    <summary type="html">对王道考研的计算机网络内容进行了整体梳理，用于考试周复习知识点</summary>
    
    
    
    <category term="Network" scheme="https://ethanbao27.github.io/categories/Network/"/>
    
    
    <category term="复习" scheme="https://ethanbao27.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="计算机网络" scheme="https://ethanbao27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络协议" scheme="https://ethanbao27.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>🛜五层体系结构协议复习</title>
    <link href="https://ethanbao27.github.io/2024/10/27/%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/"/>
    <id>https://ethanbao27.github.io/2024/10/27/%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/</id>
    <published>2024-10-27T12:00:00.000Z</published>
    <updated>2024-10-31T14:23:18.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五层体系结构协议复习">🛜五层体系结构协议复习</h1><p>首先我们需要了解为什么计算机网络要学习<strong>五层结构模型（TCP/IP模型）</strong>，因为这更简化，便于我们了解实际网络协议，并且更贴近现实的网络组成。</p><p>而七层模型（OSI）则是由<strong>国际标准化组织ISO</strong>制定的，为网络设计提供了框架，这其实是一个概念模型，虽然在实际上不常用，但为网络设计提供了参考。</p><h2 id="层">层</h2><p>让我们来看一下五层和七层有哪些层次，七层实际上在五层基础上加了两层：</p><ul><li>物理层 Physical</li><li>数据链路层 Data Link</li><li>网络层 Network</li><li>传输层 Transport<ul><li>会话层 Session</li><li>表示层 Presentation</li></ul></li><li>应用层 Application</li></ul><p>对于学过计网的人来说，夹在第四和第五之间的两个层或许不太熟悉，我们来介绍一下。<strong>会话层</strong>负责建立、管理和终止应用程序之间的会话。可见主要是Socket的建立和关闭操作。因为<strong>传输层</strong>只负责端到端的可靠传输，而给上层提供接口靠的是Session层；再看看<strong>表示层</strong>，它负责处理数据表示形式，包括加密、解密、压缩和格式化，确保不同系统之间的数据能正确解释，例如SSL/TLS加密、JPEG格式转换。可见表示层更切近应用层的具体应用。</p><p>让我们回归正题，复习一下五层结构的各类协议/技术。</p><h2 id="物理层">物理层</h2><p>实现设备之间的比特传输，定义物理连接（相邻的主机到主机）的标准。</p><ul><li>Ethernet（以太网）：有限网络的电气和信号标准。</li><li>IEEE 802.11（Wi-Fi）：定义无线局域网的通信方式。</li><li>光纤：高速骨干网传输。</li><li>Bluetooth（蓝牙）：短距离无线通信协议。</li></ul><h2 id="数据链路层">数据链路层</h2><p>实现同一局域网中的节点（主机和主机）间通信，负责帧的封装、差错检测和流量控制。</p><ul><li><p><strong>Ethernet（以太网）</strong>：最广泛的局域网数据传输协议，实现以太帧（Frame）格式的定义和介质访问控制。</p></li><li><p><strong>PPP（Point-to-PointProtocal）</strong>：提供点到点的链路传输，如电话拨号。<em>（也有特殊格式的帧）</em></p></li><li><p><strong>HDLC（High-Level Data LinkControl）</strong>：面向比特的链路控制协议，用来实现<strong>时钟同步</strong>。<em>（也有特殊格式的帧）</em></p></li><li><p><strong>ARP（Address ResolutionProtocol）</strong>：将IP地址解析为MAC地址，用于局域网通信，实现从三层到二层转换的方式。</p></li><li><p>VLAN（VirtualLAN）技术：虚拟局域网，使得相同交换机下的主机可以分配到不同子网。</p></li></ul><h2 id="网络层">网络层</h2><p>实现不同网络（局域网）之间的数据传输，负责路径选择和路由转发，实现Internet上主机到主机的连接。</p><ul><li><strong>IP（InternetProtocol）</strong>：网络层核心，定义数据包的封装与路由，它的任务只是根据<strong>数据包标头的ip地址，将数据包从源主机传送到目标主机</strong>。<ul><li>IPv4:广泛使用的协议，32位IP地址，使用ARP协议地址解析。</li><li>IPv6：128位地址，采用NDP协议。</li></ul></li><li><strong>ICMP（Internet Control MessageProtocol）</strong>：用于传递网络层错误消息和状态消息，广为流传的ping指令。它是依靠IP协议的协议，IP数据包中有它。利用TTL将路由诊断信息返回到源。</li><li>IGMP（Internel Group Management Protocol）：实现IP多播。</li></ul><figure><img src="/images/routing.png" alt="路由协议分类" /><figcaption aria-hidden="true">路由协议分类</figcaption></figure><h3 id="路由协议">路由协议</h3><h4 id="距离向量路由协议-dvrp">距离向量路由协议 DVRP</h4><p>距离向量路由协议（DVRP）也被称为“按<strong>跳数</strong>计算的路由算法”，其原理是：<strong>每个节点都维护到达目的节点所需的距离，每次更新将本节点到所有其他节点的距离向量发送给相邻节点，相邻节点再将其发给相邻节点……直到所有节点的距离向量被更新。最终每个节点都得到了到达目的节点的最短距离。</strong></p><p>常见的距离向量路由协议有</p><ul><li>RIP（Routing Information Protocol）</li><li>IGRP（Interior Gateway Routing Protocol）</li></ul><h4 id="链路状态路由协议-lsrp">链路状态路由协议 LSRP</h4><p>链路状态路由协议（LSRP）也被称为“基于<strong>状态</strong>的路由算法”，其原理是<strong>每个节点都把自己的链路状态信息发给相邻节点，相邻节点保存下来并传递给其它相邻节点。当所有节点都交换完成链路状态信息之后，每个节点通过计算最短路径算法得到网络的最短路径。</strong></p><p>常见的链路状态路由协议有</p><ul><li>OSPF（Open Shortest Path First）</li><li>IS-IS（Intermediate System to Intermediate System）</li></ul><h4 id="静态路由协议">静态路由协议</h4><p>在静态路由协议中，网络管理员<strong>手动配置路由表</strong>，然后<strong>路由器依据配置的路由表进行数据包的转发</strong>。</p><p>静态路由协议的<strong>缺点</strong>是不灵活，不能及时响应网络拓扑结构的变化。</p><h4 id="动态路由协议">动态路由协议</h4><p>动态路由协议可以根据网络拓扑结构的变化自动调整路由表，路由表的计算是通过运行路由协议来完成的。动态路由协议虽然比静态路由协议更复杂，但是具有灵活、自适应、可靠的优点。</p><p>常见的动态路由协议有</p><ul><li>BGP</li><li>OSPF</li><li>IS-IS</li><li>RIP</li><li>IGRP</li><li>EIGRP</li><li>OSPFv3</li></ul><h4 id="单播多播组播路由协议">单播、多播、组播路由协议</h4><p>单播路由协议是指进行单播转发的路由协议。多播路由协议是指进行多播转发的路由协议。组播路由协议是一种组播数据包传输的路由协议，与多播路由协议类似。</p><h4 id="内部网关协议和外部网关协议">内部网关协议和外部网关协议</h4><p>内部网关协议（IGP）是指在一个企业或组织内部部署、用于内部路由器之间通信的协议，如RIP、IGRP、EIGRP、OSPF和IS-IS等。外部网关协议（EGP）是指在不同的自治系统之间进行路由选择的协议，如BGP,各大ISP进行连接使用的是BSP协议（使用TCP连接）。</p><h4 id="工作原理">工作原理</h4><p>路由协议的工作原理可以分为四个步骤：</p><ul><li>邻居发现</li><li>路由表建立</li><li>路由表维护</li><li>路由表选择</li></ul><p>在选择适合特定网络环境的路由协议时，需要综合考虑网络规模、复杂性、性能需求和管理能力。通常，大型企业网络和互联网使用链路状态协议（如OSPF和IS-IS），而小型网络可能会选择距离向量协议（如RIP）。同时，BGP在连接自治系统之间的路由选择方面具有广泛的应用。</p><blockquote><p>以上路由协议部分内容均为<ahref="https://bbs.huaweicloud.com/blogs/399479">这篇华为云社区文章</a>的原创内容，本博客仅作为个人学习使用，无抄袭意图，了解详情请点击超链接进入此博客观看。</p></blockquote><h2 id="传输层">传输层</h2><p>提供端到端（port）的数据传输服务，确保数据包按顺序、无误地传输到目的主机。</p><ul><li><strong>TCP（Transmission ControlProtocol）</strong>：面向连接、可靠的协议，提供可靠的数据传输和流量控制。适用于需要保证数据完整性的应用，如HTTP、FTP。</li><li><strong>UDP（User DatagramProtocol）</strong>：无连接协议，不保证数据的可靠传输，但传输速度快。适用于实时应用，如视频流、在线游戏，DNS解析也用UDP。</li></ul><figure><img src="/images/transmission.jpg" alt="握手过程" /><figcaption aria-hidden="true">握手过程</figcaption></figure><ul><li>SCTP（Stream Control TransmissionProtocol）：同时支持多流传输的协议，适用于 VoIP 等应用。</li></ul><p>TCP与UDP的区别之一是<strong>重传丢失的数据</strong>。在TCP协议中，每个数据包都被赋予一个<strong>唯一的序列号</strong>。数据包发送者仔细跟踪发送了哪些数据包。作为响应，接收系统发出一个ACK数据包（代表“确认”），其中包含确认收到的数据包的序列号。如果序列号不匹配或丢失，发送机器将重新发送数据包。这个过程会持续下去，直到匹配的ACK确认传输成功。</p><p>第二大区别是通过<strong>三向握手建立持久化连接</strong>。在TCP中，三向握手是一种通信机制，以确保所有数据的发送和正确接收。简而言之，这发生在三个部分：</p><ul><li>初始化(SYN)：SYN是想要建立通信的设备发出的初始数据包。该数据包包含同步标志(SYN)和接收者的IP地址。</li><li><strong>确认启动(SYN-ACK)：</strong>接下来，接收者发回SYN-ACK数据包，假设它已准备好并愿意进行通信。</li><li><strong>最终确认(ACK)：</strong>一旦发送方收到SYN-ACK，就会发送最终ACK以确认有效连接。</li></ul><p>TCP面向连接是依赖于它的<strong>错误检测和流量控制</strong>等其他功能<em>（在后文）</em>，这些特性成为TCP面向连接的本质的支柱。</p><h4 id="tcp错误检测和流量控制简述">TCP错误检测和流量控制简述</h4><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过MSS（TCP 最大报文段长度），就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在TCP 协议中，我们把每个分块称为一个 TCP 段（TCP Segment）（IP是超过MTU1500Bytes，即以太网帧的载荷后分片，⚠️注意分片标识、偏移量、MF更多分片标识、DF禁止分片标识这些概念）。TCP段对应标识有Seq序列号（如何组装在一起）、确认号（希望接受的下一个字节的序号，累积确认机制标识以及成功接受的数据，未确认的字节等待重传）、FIN关闭连接等。</p><p>在 TCP 报文段的头部中，有一个 <strong>16位窗口字段</strong>，用于表示接收方的缓冲区可用空间大小。<strong>窗口大小值</strong>告诉发送方当前允许发送的未确认数据量。通过该字段，发送方可以动态调整发送速度，确保不会导致接收方的缓冲区溢出。如果接收方缓冲区剩余空间减少，它会将窗口大小缩小；如果可用空间增大，它会增大窗口大小。</p><h2 id="应用层">应用层</h2><p>为应用程序提供网络服务接口，用户可以直接使用这些协议访问网络资源。</p><ul><li><p><strong>HTTP/HTTPS（Hypertext TransferProtocol）</strong>：用于传输网页数据，HTTPS 在 HTTP基础上添加了加密（TLS/SSL）。</p><figure><img src="/images/ssl1.png" alt="ssl1" /><figcaption aria-hidden="true">ssl1</figcaption></figure><figure><img src="/images/ssl2.png" alt="ssl2" /><figcaption aria-hidden="true">ssl2</figcaption></figure></li><li><p><strong>FTP（File TransferProtocol）</strong>：用于文件传输，支持上传和下载功能。</p></li><li><p><strong>SMTP（Simple Mail TransferProtocol）</strong>：用于电子邮件发送。</p></li><li><p><strong>POP3（Post Office Protocol 3）</strong> 和<strong>IMAP（Internet Message AccessProtocol）</strong>：用于电子邮件接收，IMAP 支持邮件同步。</p></li><li><p><strong>DNS（Domain Name System）</strong>：将域名解析为 IP地址。</p></li></ul><figure><img src="/images/ssh.png" alt="ssh" /><figcaption aria-hidden="true">ssh</figcaption></figure><ul><li><p><strong>Telnet</strong> 和<strong>SSH</strong>：用于远程登录，SSH 提供了加密的传输。</p></li><li><p><strong>DHCP（Dynamic Host ConfigurationProtocol）</strong>：用于自动分配 IP 地址。</p></li></ul><h4 id="urluniform-resource-identifier统一资源定位符">URL（uniformresource identifier，统一资源定位符）</h4><p>在HTTP协议中，用来标识唯一的资源。</p><p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</p><h5 id="url组成">URL组成</h5><ol type="1"><li>访问资源的命名机制</li><li>存放资源的主机名</li><li>资源自身的名称，由路径表示，着重强调于资源。</li></ol><h4 id="http-request">HTTP Request</h4><figure><img src="/images/http1.webp" alt="http request" /><figcaption aria-hidden="true">http request</figcaption></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/562f25980001b1b106000338.jpg</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept    image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer    http://www.imooc.com/</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=0.8</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure><h4 id="http-response">HTTP Response</h4><figure><img src="/images/http2.webp" alt="http response" /><figcaption aria-hidden="true">http response</figcaption></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET     请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</span><br><span class="line">PUT     从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE      请求服务器删除指定的页面。</span><br><span class="line">CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS     允许客户端查看服务器的性能。</span><br><span class="line">TRACE     回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure><p>关于HTTP协议，详情可参考<ahref="https://www.cnblogs.com/ranyonsue/p/5984001.html">这篇博客</a></p><h4 id="sslssh">SSL&amp;SSH</h4><p>SSH和SSL(都是网络安全协议，通过加密和认证提升两台设备间传输数据的安全性。但SSH和SSL的生效方式和服务目标存在差异。</p><p>SSH在两台设备间创建<strong>安全隧道</strong>，使这两台设备间可以安全地发送命令、传输数据等。例如，客户端通过SSH远程登录到一台服务器上，就可以安全地远程管理这台服务器，在服务器上执行想要的命令。</p><p>SSL则是使用<strong>SSL证书</strong>保证两台设备间安全地传输数据，而不是像SSH那样可以执行命令。例如，用户通过浏览器访问某安装了SSL证书且启用了HTTPS的服务器，浏览器和服务器之间可以安全地传输数据。</p><p>SSH就像一辆汽车，我们看不到这辆封闭的汽车里装载的是什么。而SSL就像一个封闭的集装箱，我们可以用不同的交通工具运输它，但看不到集装箱里装的是什么。</p>]]></content>
    
    
    <summary type="html">介绍了大部分五层体系结构协议，TCP/IP协议，帮助复习计算机网络知识。</summary>
    
    
    
    <category term="Network" scheme="https://ethanbao27.github.io/categories/Network/"/>
    
    
    <category term="复习" scheme="https://ethanbao27.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="计算机网络" scheme="https://ethanbao27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络协议" scheme="https://ethanbao27.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>OS：处理机调度与死锁🔒</title>
    <link href="https://ethanbao27.github.io/2024/10/26/chapter%203%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/"/>
    <id>https://ethanbao27.github.io/2024/10/26/chapter%203%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/</id>
    <published>2024-10-26T05:43:00.000Z</published>
    <updated>2024-10-26T18:10:46.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理机调度与死锁">处理机调度与死锁🔒</h1><blockquote><p>Q:如果系统只有一个cpu,有两个进程要运行.进程A的运行时间将是1小时,进程B的运行时间是1分钟.那么认为操作系统让哪个进程先运行比较合理?</p></blockquote><p>A：与操作系统的调度策略有关，即更重视优先级还是到来顺序、时长等因素。</p><h2 id="调度">调度</h2><p>对处理机（CPU）资源进行分配。</p><h3 id="调度层次">调度层次</h3><p>高级（作业）调度、中级（内存）调度、低级（进程）调度。</p><p>区分主要是运行频率，<strong>低级调度最频繁</strong>，也是重点。</p><figure><img src="/images/diaodu1.png" alt="调度等级" /><figcaption aria-hidden="true">调度等级</figcaption></figure><p><strong>后备队列</strong>（Spooling Queue 或 BackupQueue）是指操作系统或系统调度过程中用于存放<strong>尚未进入内存执行的进程或任务</strong>的队列。根据实际情况，后备队列可以位于<strong>外存</strong>或与外存相关的区域，而非内存。</p><p>作业（Job）：一组需要完成的任务或程序的组合。</p><ul><li>高级调度：决定哪些后备队列中的（外存中的）作业调入内存并创建进程与分配资源。</li><li>中级调度：决定哪些进程<u>可参与竞争CPU</u>。（内存-&gt;外存）</li><li>低级调度：决定哪个进程可以<u>获得CPU。</u></li></ul><p>低级调度有两种方式：</p><ol type="1"><li>非抢占式：一直执行完成或自动阻塞。</li><li>抢占式：允许其他进程依据一定规则抢占CPU。</li></ol><p>（1）时间片原则、（2）优先权原则 、（3）短作业（进程）优先原则</p><figure><img src="/images/diaodu2.png" alt="调度设计" /><figcaption aria-hidden="true">调度设计</figcaption></figure><h2 id="周转时间-turnaround-time">1. 周转时间 (Turnaround Time)</h2><p>作业（进程）从提交（进入时刻）到完成的时间称为该作业的周转时间(T_i)：</p><p><span class="math display">\[T_i = \text{完成时刻} - \text{进入时刻}\]</span></p><h2 id="平均周转时间-average-turnaround-time">2. 平均周转时间 (AverageTurnaround Time)</h2><p>平均周转时间为 (n) 个作业（进程）周转时间的平均值：</p><p><span class="math display">\[T = \frac{1}{n} \left( \sum_{i=1}^{n} T_i \right)\]</span></p><h2 id="带权周转时间-weighted-turnaround-time">3. 带权周转时间 (WeightedTurnaround Time)</h2><p>作业（进程）周转时间 (T_i) 与实际运行时间 (T_{si})之比称为该作业的带权周转时间 (W_i)：</p><p><span class="math display">\[W_i = \frac{T_i}{T_{si}}\]</span></p><h2 id="平均带权周转时间-average-weighted-turnaround-time">4.平均带权周转时间 (Average Weighted Turnaround Time)</h2><p>平均带权周转时间为 (n) 个作业（进程）带权周转时间的平均值：</p><p><span class="math display">\[W = \frac{1}{n} \left( \sum_{i=1}^{n} \frac{T_i}{T_{si}} \right)\]</span></p><h2 id="调度算法">调度算法</h2><p>根据系统的资源分配策略所规定的资源分配方法</p><ol type="1"><li><h3 id="先来先服务fcfs">先来先服务（FCFS）</h3></li></ol><p>​ 作业调度：从后背队列选择一个或多个最先进入队列的作业</p><ol start="2" type="1"><li><h3 id="短作业进程优先sf">短作业（进程）优先（SF）</h3><p>从就绪队列中选择CPU执行时间最短的作业</p></li><li><h3 id="高响应比优先hrn">高响应比优先（HRN）</h3></li></ol><p>​ 选择待调度的作业中响应比最高的 <span class="math display">\[R_p = \frac{W_i + S_i}{S_i}\]</span> ​ Rp:响应比</p><p>​ Wi：已等待时间</p><p>​ Si：要求服务时间</p><ol start="4" type="1"><li><h3 id="最高优先权hpf">最高优先权（HPF）</h3></li></ol><p>​ 选择优先权最高的，其中又分为：</p><p>​ <strong>静态优先权</strong></p><p>​ <strong>动态优先权</strong></p><ol start="5" type="1"><li><h3 id="时间片轮转rr">时间片轮转（RR）</h3></li></ol><p>​ 每次为一个进程执行一个时间片T</p><ol start="6" type="1"><li><h3 id="多级队列调度">多级队列调度</h3></li></ol><p>​ 将就绪队列分为多种不同队列，不同队列使用不同调度算法</p><p>​ <img src="/images/diaodu0.png" alt="img" /></p><ol start="7" type="1"><li><h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3></li></ol><p>​设置多个就绪队列，从高到低赋予不同优先级，每个队列采用RR算法，时间片长度依次增加。</p><h2 id="死锁">死锁</h2><h3 id="概述">概述</h3><p><strong>死锁</strong>是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前进。</p><h3 id="产生原因">产生原因</h3><ol type="1"><li><strong>资源竞争</strong></li></ol><ul><li><p>当两个或以上进程需要两个或以上资源(非剥夺性资源or临时性资源)：</p><ol type="1"><li>可剥夺性资源</li><li>非剥夺性资源</li><li>临时性资源：由某进程产生，由另一进程使用的资源。（信号量）</li></ol></li></ul><ol start="2" type="1"><li><p><strong>进程推进非法</strong></p><p>请求和释放资源的顺序不当。</p></li></ol><h3 id="产生死锁必要条件">产生死锁必要条件</h3><ol type="1"><li><p>互斥条件：请求的资源为<strong>临界资源</strong></p><p><strong>临界资源（CriticalResource）</strong>：指<strong>多个进程或线程在同一时间只能由一个进程使用</strong>的资源。对这种资源的访问必须受到严格的控制，以防止数据<strong>不一致</strong>或<strong>竞争</strong>问题的发生。典型的临界资源包括<strong>共享内存、文件、数据库</strong>等。</p><blockquote><p>可见，访问临界资源必须要有<strong>同步或互斥机制（同步：信号量，互斥：锁）！！</strong></p></blockquote></li><li><p>请求和保持条件：申请新资源，保持旧资源</p></li><li><p>不剥夺条件：已获得的资源，在使用完之前，不被外力剥夺。</p></li><li><p>环路等待条件：互相等待资源</p></li></ol><h3 id="处理死锁的基本方法">处理死锁的基本方法</h3><ol type="1"><li>预防死锁：设置限制条件，破坏死锁产生</li><li>避免死锁：资源分配的动态方法</li><li>检测死锁：采取措施，解除死锁</li><li>解除死锁：剥夺资源或撤销进程回收♻️资源</li></ol><h2 id="银行家算法">银行家算法🏦</h2><h3 id="安全序列">安全序列</h3><p>安全状态，是指系统能按某种进程顺序(P1, P2, …，Pn)(称〈P1, P2, …,Pn〉序列为安全序列)，来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p><p>​ • <strong>可用资源</strong>：目前系统中剩余的可用资源数量。</p><p>​ • <strong>最大需求</strong>：每个进程所需的最大资源量。</p><p>​ • <strong>已分配资源</strong>：每个进程当前占用的资源量。</p><p>需求 = <strong>最大需求</strong> - <strong>已分配资源</strong></p><p>要找到一个<strong>安全序列</strong>，需要按照银行家算法，依次寻找一个可以满足当前可用资源条件的进程，完成该进程后，释放其资源，增加可用资源。重复这个过程，直到所有进程都完成。</p><h3 id="算法实现">算法实现</h3><p>核心：根据系统是否处于安全状态，来决定分配资源与否。</p><p>对于银行家算法的具体实现主要由以下几个数据结构：</p><p>1、可利用资源向量Available：</p><p>一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目</p><p>2、最大需求矩阵Max：</p><p>一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求</p><p>3、分配矩阵Allocation：</p><p>一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数</p><p>4、需求矩阵Need：</p><p>一个n×m的矩阵，用以表示每一个进程还需的各类资源数</p><p>Need［i,j］=Max［i,j］-Allocation［i,j］</p><figure><img src="/images/bank.png" alt="银行家算法" /><figcaption aria-hidden="true">银行家算法</figcaption></figure><p>设Requesti是进程Pi的请求向量，如果Requesti［j］=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：</p><ol type="1"><li><p>如果Requesti［j］≤Need［i,j］，便转向步骤2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</p></li><li><p>如果Requesti［j］≤Available［j］，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。</p></li><li><p>系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：</p></li></ol><p>① Available［j］∶=Available［j］-Requesti［j］;</p><p>② Allocation［i,j］∶=Allocation［i,j］+Requesti［j］;</p><p>③ Need［i,j］∶=Need［i,j］-Requesti［j］;</p><ol start="4" type="1"><li>系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。对于系统整体安全状态的检查，引入安全性算法，核心实现如下：</li></ol><blockquote><ol type="1"><li>设置两个向量：① 工作向量Work:它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work∶=Available;② Finish:它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish［i］∶=false;当有足够资源分配给进程时， 再令Finish［i］∶=true。</li><li>从进程集合中找到一个能满足下述条件的进程：  ① Finish［i］=false; ②Need［i,j］≤Work［j］； 若找到， 执行步骤(3)，否则，执行步骤(4)。<br /></li><li>当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：Work［j］∶=Work［i］+Allocation［i,j］; Finish［i］∶=true; go to step2;</li><li>如果所有进程的Finish［i］=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</li></ol></blockquote><p>银行家算法的缺点如下：</p><p>1.很少有进程能够在运行前就知道其所需资源的最大值</p><p>2.而且进程数也不是固定的，往往在不断地变化（如新用户登录或退出）</p><p>3.原本可用的资源也可能突然间变成不可用（如磁带机可能坏掉）</p><p>4.银行家算法的开销较大，实时性不是很好</p><h2 id="解除死锁">解除死锁</h2><p>利用死锁定理</p><figure><img src="/images/diaodu3.png" alt="死锁解除" /><figcaption aria-hidden="true">死锁解除</figcaption></figure><p>对于死锁的解除，即<strong>（1）剥夺资源，(2) 撤消进程</strong>。</p><p>实用而又简便的方法是：<strong>逐个</strong>撤消那些<strong>代价最小</strong>的进程，或者，使<strong>撤消进程的数量最少</strong>，直至获得为解除死锁所需要的足够可用的资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;处理机调度与死锁&quot;&gt;处理机调度与死锁🔒&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Q:如果系统只有一个cpu,有两个进程要运行.进程A的运行时间将是1小时,进程B的运行时间是1分钟.那么认为操作系统让哪个进程先运行比较合理?&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="OS" scheme="https://ethanbao27.github.io/categories/OS/"/>
    
    
    <category term="操作系统" scheme="https://ethanbao27.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="死锁" scheme="https://ethanbao27.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
    <category term="复习" scheme="https://ethanbao27.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最常见的图像压缩算法：JPEG</title>
    <link href="https://ethanbao27.github.io/2024/10/22/%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%9AJPEG/"/>
    <id>https://ethanbao27.github.io/2024/10/22/%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%9AJPEG/</id>
    <published>2024-10-22T08:22:03.000Z</published>
    <updated>2024-10-26T18:09:55.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dip-jpeg图像压缩">DIP-JPEG图像压缩</h1><h2 id="为什么jpefg有用">为什么JPEFG有用</h2><p>人类眼镜的细胞对图像的感知程度，亮度比色度感知强烈的多。</p><p>因此减少人类眼镜感知较弱的区域，即减少颜色的差异，就可以实现压缩。</p><h2 id="压缩步骤">压缩步骤</h2><ol type="1"><li><p>首先需要进行色彩空间转换，每一个像素都有RGB的红绿蓝叠加，算法需要通过一个固定的公式算出<strong>Y（亮度）、Cb（蓝色色度）、Cr（红色色度）</strong>。</p></li><li><p>进行色度缩减取样，很多数据会被删除。将蓝色和红色色度分量层的像素按照2x2像素成一个区块这样划分。然后计算每个区块的平均值，然后缩小图像（4:2:0），使得含有1个平均值的由4个像素组成的区块只占一个像素的空间。于是那些我们👀眼睛不易感知的红蓝色度信息量shrinkto 1/4size，而亮度（luminance）保持不变。<em>（网上流行的包浆图就是这么来的）</em></p><blockquote><p>考虑一下刚才的两步，计算之前SIZE=1+1+1=3.0，计算之后为SIZE=1+1/4+1/4=1.5，图像已经变为原来大小的一半了。</p></blockquote></li><li><p>当我们查看图像时，会放大图像到原始尺寸，根据YCbCr重新计算RGB<em>（可能发生变化）</em></p></li><li><p>接下来的两个步骤是<strong>重点</strong>，进行<strong>离散余弦变换（DiscreteCosine Transform,DCT）</strong>和<strong>量化（Quantiaztion）</strong>。这利用了人眼不擅长感知高频率的图像信息的原理，即对于细节并不能精确感知。如阴影变化，和摄影中失焦的场景。以上两个步骤会遍历图像各个部分，并找到由高频率色度或亮度的像素频繁出现的区域，然后将这些人眼很难感知的像素删除。对于三个图层中的每一个图层进行以下步骤<em>（以亮度涂层举例）</em>：</p><ul><li>将整个图像<strong>按照8x8像素划分成许多区域</strong>，称为“区块”。每个区块因此有64像素，每个像素用0～255的数值表示。如果是亮度图层就是代表亮度值。</li><li>减去128来改变各个亮度数值，这样取值范围就变成了-128～-127。（亮度图-128为黑色，127为白色）</li><li>每一个区块内，我们可以先找到64个8x8基本图像（正弦函数的频率域图）并且每个图像都会有一个计算得出的DCT系数，原始图像可以通过计算出的每个基本图像✖️它对应的系数后再叠加64次得出。<em>（具体的数学公式笔者也不了解，请自行网上查阅）</em></li></ul><blockquote><p>DCT不能压缩或缩小图像，但下一个步骤，量化可以</p></blockquote></li><li><p>DCT后我们会有一个常数表，我们要把其中的各个值除上对应量化表中的各个值，并四舍五入取整。</p><figure><img src="/images/jpeg-0.png" alt="量化过程" /><figcaption aria-hidden="true">量化过程</figcaption></figure></li></ol><p>​ 量化表右下角数值偏高，是人眼不擅长感知德高频数据。而数值较小的左上角是人眼更容易区分的样式所在。</p><p>​ 在刚才的步骤中，我们舍弃了人眼无法感知的数据，针对色度，我们会采用一个数值更大的量化表，舍去更多的颜色数据。</p><h2 id="小结">小结</h2><ul><li>从本质上讲，整个余弦变换+量化的过程，<strong>一整张图像都使用了一组相同的64个基础图像和两个量化表：一个用于亮度，另一个用于色度。以便将8x8的像素区块转换为几个数字和一大堆的0。</strong></li></ul><h2 id="编码">编码</h2><h3 id="游程编码">游程编码</h3><ul><li><p>在这一步骤中，我们列出所有区块中的亮度与色度数值（更改后）。然而是这样的顺序：</p><figure><img src="/images/jpeg-1.png" alt="游程编码" /><figcaption aria-hidden="true">游程编码</figcaption></figure></li><li><p>因为这样子更可能找到一连串的非0数字。</p></li><li><p>接下来，在我们列出的数字中，使用游程编码Run length encodingalgorithm，列出我们有几个0。这样只有几十个数字的列表显然比0～255的方法压缩的多。</p></li></ul><p><img src="/images/jpeg-2.png" style="zoom:50%;" /></p><h3 id="哈夫曼编码-huffman-encoding">哈夫曼编码 Huffman Encoding</h3><p>​这种独立编码也运用在H.264视频压缩算法中（也被称为高级视频编码，AVC），是目前Youtube上传视频推荐的视频压缩算法。它使用了色度所见取样或色度抽样技术，以及离散余弦变换和量化技术的一些变种。</p><p>​ 这里对哈夫曼编码进行简述，感兴趣的可以查阅资料自行了解。</p><ol type="1"><li><p>需要对待编码的数据中每个符号出现的频率进行统计。这些频率将用于构建哈夫曼树。</p></li><li><p>哈夫曼树是一种二叉树，其中每个叶子节点代表一个符号，且路径长度与符号的频率相关。构建哈夫曼树的步骤如下：</p><p>​ 1.<strong>初始化</strong>：将所有符号视为独立的节点，并按照频率从小到大排序。</p><p>​ 2.<strong>合并最小频率的两个节点</strong>：将频率最小的两个节点合并为一个新的父节点，其频率为两个子节点频率之和。</p><p>​ 3.<strong>重复合并</strong>：将新节点加入节点列表中，重新排序，重复步骤2，直到所有节点合并成一棵树。</p></li><li><p>根据哈夫曼树<strong>生成哈夫曼表</strong>，从根节点到每个叶子节点的路径决定了该符号的哈夫曼编码。通常，向左分支记为0，向右分支记为1。</p></li></ol><pre class="mermaid">graph TDRoot[100]Root --> A[45]Root --> CBFED[55]CBFED --> CB[25]CBFED --> FED[30]CB --> C[12]CB --> B[13]FED --> FE[14]FED --> D[16]FE --> F[5]FE --> E[9]</pre><pre class="mermaid">classDiagramclass HuffmanTable {    +Symbol : A    +Code : 0    +Symbol : B    +Code : 101    +Symbol : C    +Code : 100    +Symbol : D    +Code : 111    +Symbol : E    +Code : 1101    +Symbol : F    +Code : 1100}</pre><h4 id="h.264">H.264</h4><p>​然而，H.264显然更加复杂，因为它不是像JPEG那样压缩单一的静态图像。每30帧使用iFrame（JPEG），而其他29帧使用预测或双向预测,只对差异和运动进行编码，同时使用先前解码的帧作为参考。</p><h4 id="重构图片过程">重构图片过程</h4><ul><li><p>让我们回到JPEG，首先我们执行哈夫曼解码,根据哈夫曼表将编码变回DCT系数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compressed Data: 110100010...</span><br><span class="line">Decoded DCT Coefficients: [16, 11, -10, ...]</span><br></pre></td></tr></table></figure></li><li><p>并且分解游程编码（disassemble），然后把一连串的数字按照<strong>去交错</strong>（De-Zigzag）的方式重新排列为8x8矩阵。</p></li><li><p>接下来，我们执行<strong>反量化</strong>，通俗来讲就是讲各个值乘以量化表（之前讲过的那两张表，之前是除法），然后将所得常数乘以相应的基础图像（基础图像也是一开始就有的，之前也是除法），并将所有结果图像叠加在一起。</p></li><li><p>将蓝色跟红色色度图像放大，并将亮度和色度值重新转换为RGB色彩空间。</p></li></ul><blockquote><p>智能手机相机的拍摄照片至少有十几万像素，JPEG在几秒钟内就要完成压缩和解压缩，真是不可思议！</p></blockquote><h2 id="jpeg的缺点">JPEG的缺点</h2><p>有时候，你可以选择压缩的程度，而这会改变量化表的数值，这种四舍五入做除法的算法，如果压缩量变大，那么就会有更多的0，图像也会因此变得更小。</p><p>然而，如果压缩量过大，图像会出现artifacts，或者说块效应。它们看起开就像方块边缘的模糊斑点（类似于基础图像，就是离散余弦变换表中的特征，图像有很明显的横线或竖线）。</p><p>其次，压缩会去除高频数据，使得图像的精确度降低。</p><p>然而，这也是一种优点，因为没有一个相机能够做到完美对焦，所以很难分辨出未压缩和压缩的图像之间的区别。</p><p>但是，压缩矢量图的表现不佳，直线的压缩会出现锯齿。因为JPEG依靠基础图像来重建直线。</p><h2 id="总结">总结</h2><p>JPEG仍是使用量最多的图片压缩算法，因为它古老、为人熟知、无版权。</p><p>但还有很多其他图像格式，也具有很好的压缩能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dip-jpeg图像压缩&quot;&gt;DIP-JPEG图像压缩&lt;/h1&gt;
&lt;h2 id=&quot;为什么jpefg有用&quot;&gt;为什么JPEFG有用&lt;/h2&gt;
&lt;p&gt;人类眼镜的细胞对图像的感知程度，亮度比色度感知强烈的多。&lt;/p&gt;
&lt;p&gt;因此减少人类眼镜感知较弱的区域，即减少颜色的差异，</summary>
      
    
    
    
    <category term="DIP" scheme="https://ethanbao27.github.io/categories/DIP/"/>
    
    
    <category term="JPEG" scheme="https://ethanbao27.github.io/tags/JPEG/"/>
    
    <category term="数字图像处理" scheme="https://ethanbao27.github.io/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="算法" scheme="https://ethanbao27.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图像压缩" scheme="https://ethanbao27.github.io/tags/%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="哈夫曼编码" scheme="https://ethanbao27.github.io/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Three.Js简介</title>
    <link href="https://ethanbao27.github.io/2024/10/21/Three-Js%E7%AE%80%E4%BB%8B/"/>
    <id>https://ethanbao27.github.io/2024/10/21/Three-Js%E7%AE%80%E4%BB%8B/</id>
    <published>2024-10-21T08:33:28.000Z</published>
    <updated>2024-10-26T18:09:01.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="three.js-介绍">Three.Js 介绍</h1><p>Three.js由Ricardo Cabello在2010四月于GitHub首次发布。</p><figure><imgsrc="data:image/png;base64,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"alt="JavaScriptの3Dライブラリ”three.js”を使って遊 ..." /><figcaptionaria-hidden="true">JavaScriptの3Dライブラリ”three.js”を使って遊...</figcaption></figure><p>Three.js是一个跨浏览器的使用JavaScript函数库或API来在网页浏览器中创建和展示三维计算机图形的开源通用3D 代码库。Three.js使用WebGL渲染图形，也可通过插件使用WebGPU（实验性）、SVG 和 CSS3D 渲染器。源代码托管在GitHub。</p><h2 id="installation">Installation</h2><p>每个 three.js 项目至少需要一个 HTML 文件来定义网页，以及一个JavaScript 文件来运行你的 three.js代码。下面的结构和命名选择并非必需，但为了保持一致性，本指南将在全文中使用。</p><ul><li><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>My first three.js app<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><code>public/</code></p><ul><li><em>public/</em> 文件夹有时也被称为"静态（static）"文件夹，因为其中包含的文件会原封不动地推送到网站上。纹理（textures）、音频和3D 模型通常会放在这里。</li></ul><h2 id="creating-a-scene">Creating a Scene</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&quot;three&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>()</span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(<span class="number">75</span>,<span class="variable language_">window</span>.<span class="property">innerWidth</span>/<span class="variable language_">window</span>.<span class="property">innerHeight</span>,<span class="number">0.1</span>,<span class="number">1000</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer =<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>()</span><br><span class="line">renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>,<span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;<span class="attr">color</span>:<span class="number">0x00ff00</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry,material)</span><br><span class="line">scene.<span class="title function_">add</span>(cube)</span><br><span class="line"></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">z</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(animate)</span><br><span class="line">    cube.<span class="property">rotation</span>.<span class="property">x</span> += <span class="number">0.01</span></span><br><span class="line">    cube.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.02</span></span><br><span class="line">    renderer.<span class="title function_">render</span>(scene,camera)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">animate</span>()</span><br></pre></td></tr></table></figure><ul><li>以上这行代码创建了一个不断旋转的正方体。</li><li><figure><img src="/images/threejs.png" alt="效果图" /><figcaption aria-hidden="true">效果图</figcaption></figure></li></ul></li></ul><h2 id="解释代码">解释代码</h2><p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。</p><p>three.js 里有几种不同的相机，在这里，我们使用的是<strong>PerspectiveCamera</strong>（透视摄像机）。</p><p>第一个参数是<strong>视野角度（FOV）</strong>。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。</p><p>第二个参数是<strong>长宽比（aspect ratio）</strong>。也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p><p>接下来的两个参数是<strong>近截面</strong>（near）和<strong>远截面</strong>（far）。当物体某些部分比摄像机的<strong>远截面</strong>远或者比<strong>近截面</strong>近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p><p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer 渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL 时，可以使用这几种渲染器进行降级。</p><p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用<strong>setSize</strong> 传入一个较小的值，例如<strong>window.innerWidth/2</strong> 和<strong>window.innerHeight/2</strong>，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p><p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用<strong>setSize</strong> 时，将<strong>updateStyle</strong>（第三个参数）设为false。例如，假设你的canvas标签现在已经具有了 100% 的宽和高，调用<strong>setSize(window.innerWidth/2, window.innerHeight/2,false)</strong> 将使得你的应用程序以四分之一的大小来进行渲染。</p><p>最后一步很重要，我们将<strong>renderer</strong>（渲染器）的dom元素（renderer.domElement）添加到我们的HTML 文档中。这就是渲染器用来显示场景给我们看的canvas元素。</p><p>要创建一个立方体，我们需要一个<strong>BoxGeometry</strong>（立方体）对象.这个对象包含了一个立方体中所有的顶点（<strong>vertices</strong>）和面（<strong>faces</strong>）。未来我们将在这方面进行更多的探索。</p><p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是<strong>MeshBasicMaterial</strong>。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为<strong>0x00ff00</strong>，也就是绿色。这里所做的事情，和在 CSS 或者Photoshop 中使用十六进制（<strong>hexcolors</strong>）颜色格式来设置颜色的方式一致。</p><p>第三步，我们需要一个 <strong>Mesh</strong>（网格）。网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p><p>默认情况下，当我们调用 <strong>scene.add()</strong>的时候，物体将会被添加到 <strong>(0,0,0)</strong>坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p><h2 id="渲染场景">渲染场景</h2><p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用一个被叫做“<strong>渲染循环</strong>”（renderloop）或者“<strong>动画循环</strong>”（animate loop）的东西。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">animate</span>() &#123; <span class="built_in">requestAnimationFrame</span>( animate ); renderer<span class="selector-class">.render</span>( scene, camera ); &#125; <span class="built_in">animate</span>();</span><br></pre></td></tr></table></figure><p>在这里我们创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说<em>“为什么我们不直接用setInterval 来实现刷新的功能呢？”</em>当然啦，我们的确可以用setInterval，但是，<strong>requestAnimationFrame</strong>有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。</p><h2 id="使立方体动起来">使立方体动起来</h2><p>在开始之前，如果你已经将上面的代码写入到了你所创建的文件中，你可以看到一个绿色的方块。让我们来做一些更加有趣的事—— 让它旋转起来。</p><p>将下列代码添加到 animate() 函数中 <strong>renderer.render</strong>调用的上方：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cube</span>.rotation.x += <span class="number">0</span>.<span class="number">01</span>; cube.rotation.y += <span class="number">0</span>.<span class="number">01</span>;</span><br></pre></td></tr></table></figure><p>这段代码每帧都会执行（正常情况下是60次/秒），这就让立方体有了一个看起来很不错的旋转动画。基本上来说，当应用程序运行时，如果你想要移动或者改变任何场景中的东西，都必须要经过这个动画循环。当然，你可以在这个动画循环里调用别的函数，这样你就不会写出有上百行代码的<strong>animate</strong> 函数。</p><h2 id="结果">结果</h2><p>祝贺你！你现在已经成功完成了你的第一个 three.js应用程序。虽然它很简单，但现在你已经有了一个入门的起点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;three.js-介绍&quot;&gt;Three.Js 介绍&lt;/h1&gt;
&lt;p&gt;Three.js由Ricardo Cabello在2010四月于GitHub首次发布。&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;data:image/png;base64,iVBORw0KGg</summary>
      
    
    
    
    <category term="前端" scheme="https://ethanbao27.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://ethanbao27.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="javascript框架" scheme="https://ethanbao27.github.io/tags/javascript%E6%A1%86%E6%9E%B6/"/>
    
    <category term="WebGL" scheme="https://ethanbao27.github.io/tags/WebGL/"/>
    
    <category term="渲染引擎" scheme="https://ethanbao27.github.io/tags/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>axios简介</title>
    <link href="https://ethanbao27.github.io/2024/10/21/axios%E7%AE%80%E4%BB%8B/"/>
    <id>https://ethanbao27.github.io/2024/10/21/axios%E7%AE%80%E4%BB%8B/</id>
    <published>2024-10-21T08:25:25.000Z</published>
    <updated>2024-10-26T06:03:25.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="axios">axios</h1><figure><img src="/images/axios.png" alt="axios" /><figcaption aria-hidden="true">axios</figcaption></figure><p>axios对原生ajax进行了封装，简化书写，快速开发，用于发送<strong>异步</strong>请求。</p><p><a href="https://axios-http.com/zh/docs/intro">查看 axiosdocs</a></p><h2 id="定义">定义</h2><p>Axios 是一个基于 <em><ahref="https://javascript.info/promise-basics">promise</a></em>网络请求库，作用于<a href="https://nodejs.org/"><code>node.js</code></a>和浏览器中。 它是 <em><ahref="https://www.lullabot.com/articles/what-is-an-isomorphic-application">isomorphic</a></em>的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js<code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</p><h2 id="用例">用例</h2><p>发起一个 <code>GET</code> 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向给定ID的用户发起请求</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理成功情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理错误情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 总是会执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述请求也可以按以下方式完成（可选）</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 总是会执行</span></span><br><span class="line">  &#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持async/await用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong> 由于<code>async/await</code> 是ECMAScript2017中的一部分，而且在IE和一些旧的浏览器中不支持，所以使用时务必要小心。</p></blockquote><p>发起一个 <code>POST</code> 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;axios&quot;&gt;axios&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;/images/axios.png&quot; alt=&quot;axios&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;axios&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://ethanbao27.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://ethanbao27.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="ajax" scheme="https://ethanbao27.github.io/tags/ajax/"/>
    
    <category term="异步" scheme="https://ethanbao27.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="javascript" scheme="https://ethanbao27.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学分支 CS Map</title>
    <link href="https://ethanbao27.github.io/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E6%94%AF/"/>
    <id>https://ethanbao27.github.io/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E6%94%AF/</id>
    <published>2024-10-20T16:02:46.371Z</published>
    <updated>2024-10-21T08:23:17.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="computer-science-map">Computer Science Map</h1><h2 id="计算机科学基础理论theroy">计算机科学基础理论（Theroy）</h2><h5 id="计算性理论-computability-theroy">1. 计算性理论 computabilitytheroy</h5><h5 id="算法-algorithm">2. 算法 algorithm</h5><h5 id="信息论-information-theroy">3. 信息论 information theroy</h5><h5 id="密码学-cryptography">4. 密码学 cryptography</h5><h5id="其他逻辑图论计算几何自动机理论量子计算并行编程形式化方法数据结构">5.其他（逻辑、图论、计算几何、自动机理论、量子计算、并行编程、形式化方法、数据结构）</h5><h2 id="计算机工程engineering">计算机工程（engineering）</h2><h5 id="处理机调度">1. 处理机调度</h5><h5 id="计算机体系结构-architecure">2. 计算机体系结构 architecure</h5><h5 id="软件与编程语言">3. 软件与编程语言</h5><h5 id="编译器-compilers">4. 编译器 compilers</h5><h5 id="操作系统-operating-systems">5. 操作系统 operating systems</h5><h5 id="软件工程-software-engineering">6. 软件工程 softwareengineering</h5><h5 id="网络-networking">7. 网络 networking</h5><h5 id="数据管理-data-management">8. 数据管理 data management</h5><h5 id="性能-performance">9. 性能 performance</h5><h5 id="图形学-graphics">10. 图形学 graphics</h5><h2 id="应用applications">应用（Applications）</h2><h5 id="优化-optimization">1. 优化 optimization</h5><h5 id="布尔可满足性问题-boolean-satisfiabilitysat">2. 布尔可满足性问题boolean satisfiability（SAT）</h5><h5 id="人工智能-artificial-intelligence">3. 人工智能 artificialintelligence</h5><h5 id="机器学习-machine-learning">4. 机器学习 machine learning</h5><ol type="1"><li>计算机视觉 computer vision</li></ol><ul><li>图像处理技术 image processing techniques</li></ul><ol start="2" type="1"><li>自然语言处理 natural language processing</li></ol><h5 id="大数据-big-data">5. 大数据 big data</h5><h5 id="物联网-internet-of-things">6. 物联网 Internet of things</h5><h5 id="hacking">7. hacking</h5><h5 id="计算科学-computational-science">8. 计算科学 computationalscience</h5><h5 id="超算-supter-computing">9. 超算 supter computing</h5><h5 id="人机交互-human-computer-interacting">10. 人机交互 human computerinteracting</h5><h5 id="机器人学-robitics">11。 机器人学 robitics</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;computer-science-map&quot;&gt;Computer Science Map&lt;/h1&gt;
&lt;h2 id=&quot;计算机科学基础理论theroy&quot;&gt;计算机科学基础理论（Theroy）&lt;/h2&gt;
&lt;h5 id=&quot;计算性理论-computability-theroy&quot;&gt;</summary>
      
    
    
    
    <category term="计算机科学" scheme="https://ethanbao27.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="计算机科学导航" scheme="https://ethanbao27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
</feed>
